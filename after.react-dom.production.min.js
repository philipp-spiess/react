/** @license React v16.4.1
 * react-dom.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
"use strict";
(function(global, factory) {
  "object" === typeof exports && "undefined" !== typeof module
    ? (module.exports = factory(require("react")))
    : "function" === typeof define && define.amd
      ? define(["react"], factory)
      : (global.ReactDOM = factory(global.React));
})(this, function(React) {
  function invariant(condition, format, a, b, c, d, e, f) {
    if (!condition) {
      condition = void 0;
      if (void 0 === format)
        condition = Error(
          "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
        );
      else {
        var args = [a, b, c, d, e, f],
          argIndex = 0;
        condition = Error(
          format.replace(/%s/g, function() {
            return args[argIndex++];
          })
        );
        condition.name = "Invariant Violation";
      }
      condition.framesToPop = 1;
      throw condition;
    }
  }
  function reactProdInvariant(code) {
    for (
      var argCount = arguments.length - 1,
        url = "https://reactjs.org/docs/error-decoder.html?invariant=" + code,
        argIdx = 0;
      argIdx < argCount;
      argIdx++
    )
      url += "&args[]=" + encodeURIComponent(arguments[argIdx + 1]);
    invariant(
      !1,
      "Minified React error #" +
        code +
        "; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ",
      url
    );
  }
  function recomputePluginOrdering() {
    if (eventPluginOrder)
      for (var pluginName in namesToPlugins) {
        var pluginModule = namesToPlugins[pluginName],
          pluginIndex = eventPluginOrder.indexOf(pluginName);
        -1 < pluginIndex ? void 0 : reactProdInvariant("96", pluginName);
        if (!plugins[pluginIndex]) {
          pluginModule.extractEvents
            ? void 0
            : reactProdInvariant("97", pluginName);
          plugins[pluginIndex] = pluginModule;
          pluginIndex = pluginModule.eventTypes;
          for (var eventName in pluginIndex) {
            var JSCompiler_inline_result = void 0;
            var dispatchConfig = pluginIndex[eventName],
              pluginModule$jscomp$0 = pluginModule,
              eventName$jscomp$0 = eventName;
            eventNameDispatchConfigs.hasOwnProperty(eventName$jscomp$0)
              ? reactProdInvariant("99", eventName$jscomp$0)
              : void 0;
            eventNameDispatchConfigs[eventName$jscomp$0] = dispatchConfig;
            var phasedRegistrationNames =
              dispatchConfig.phasedRegistrationNames;
            if (phasedRegistrationNames) {
              for (JSCompiler_inline_result in phasedRegistrationNames)
                phasedRegistrationNames.hasOwnProperty(
                  JSCompiler_inline_result
                ) &&
                  publishRegistrationName(
                    phasedRegistrationNames[JSCompiler_inline_result],
                    pluginModule$jscomp$0,
                    eventName$jscomp$0
                  );
              JSCompiler_inline_result = !0;
            } else
              dispatchConfig.registrationName
                ? (publishRegistrationName(
                    dispatchConfig.registrationName,
                    pluginModule$jscomp$0,
                    eventName$jscomp$0
                  ),
                  (JSCompiler_inline_result = !0))
                : (JSCompiler_inline_result = !1);
            JSCompiler_inline_result
              ? void 0
              : reactProdInvariant("98", eventName, pluginName);
          }
        }
      }
  }
  function publishRegistrationName(registrationName, pluginModule, eventName) {
    registrationNameModules[registrationName]
      ? reactProdInvariant("100", registrationName)
      : void 0;
    registrationNameModules[registrationName] = pluginModule;
    registrationNameDependencies[registrationName] =
      pluginModule.eventTypes[eventName].dependencies;
  }
  function injectEventPluginOrder(injectedEventPluginOrder) {
    eventPluginOrder ? reactProdInvariant("101") : void 0;
    eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
    recomputePluginOrdering();
  }
  function injectEventPluginsByName(injectedNamesToPlugins) {
    var isOrderingDirty = !1,
      pluginName;
    for (pluginName in injectedNamesToPlugins)
      if (injectedNamesToPlugins.hasOwnProperty(pluginName)) {
        var pluginModule = injectedNamesToPlugins[pluginName];
        (namesToPlugins.hasOwnProperty(pluginName) &&
          namesToPlugins[pluginName] === pluginModule) ||
          (namesToPlugins[pluginName]
            ? reactProdInvariant("102", pluginName)
            : void 0,
          (namesToPlugins[pluginName] = pluginModule),
          (isOrderingDirty = !0));
      }
    isOrderingDirty && recomputePluginOrdering();
  }
  function executeDispatch(event, simulated, listener, inst) {
    simulated = event.type || "unknown-event";
    event.currentTarget = getNodeFromInstance(inst);
    ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(
      simulated,
      listener,
      void 0,
      event
    );
    event.currentTarget = null;
  }
  function accumulateInto(current, next) {
    null == next ? reactProdInvariant("30") : void 0;
    if (null == current) return next;
    if (Array.isArray(current)) {
      if (Array.isArray(next))
        return current.push.apply(current, next), current;
      current.push(next);
      return current;
    }
    return Array.isArray(next) ? [current].concat(next) : [current, next];
  }
  function forEachAccumulated(arr, cb, scope) {
    Array.isArray(arr) ? arr.forEach(cb, scope) : arr && cb.call(scope, arr);
  }
  function getListener(inst, registrationName) {
    var listener = inst.stateNode;
    if (!listener) return null;
    var props = getFiberCurrentPropsFromNode(listener);
    if (!props) return null;
    listener = props[registrationName];
    a: switch (registrationName) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
        (props = !props.disabled) ||
          ((inst = inst.type),
          (props = !(
            "button" === inst ||
            "input" === inst ||
            "select" === inst ||
            "textarea" === inst
          )));
        inst = !props;
        break a;
      default:
        inst = !1;
    }
    if (inst) return null;
    listener && "function" !== typeof listener
      ? reactProdInvariant("231", registrationName, typeof listener)
      : void 0;
    return listener;
  }
  function runEventsInBatch(events, simulated) {
    null !== events && (eventQueue = accumulateInto(eventQueue, events));
    events = eventQueue;
    eventQueue = null;
    events &&
      (simulated
        ? forEachAccumulated(events, executeDispatchesAndReleaseSimulated)
        : forEachAccumulated(events, executeDispatchesAndReleaseTopLevel),
      eventQueue ? reactProdInvariant("95") : void 0,
      ReactErrorUtils.rethrowCaughtError());
  }
  function runExtractedEventsInBatch(
    topLevelType,
    targetInst,
    nativeEvent,
    nativeEventTarget
  ) {
    for (var events = null, i = 0; i < plugins.length; i++) {
      var possiblePlugin = plugins[i];
      possiblePlugin &&
        (possiblePlugin = possiblePlugin.extractEvents(
          topLevelType,
          targetInst,
          nativeEvent,
          nativeEventTarget
        )) &&
        (events = accumulateInto(events, possiblePlugin));
    }
    runEventsInBatch(events, !1);
  }
  function precacheFiberNode(hostInst, node) {
    node[internalInstanceKey] = hostInst;
  }
  function getClosestInstanceFromNode(node) {
    if (node[internalInstanceKey]) return node[internalInstanceKey];
    for (; !node[internalInstanceKey]; )
      if (node.parentNode) node = node.parentNode;
      else return null;
    node = node[internalInstanceKey];
    return 5 === node.tag || 6 === node.tag ? node : null;
  }
  function getNodeFromInstance$1(inst) {
    if (5 === inst.tag || 6 === inst.tag) return inst.stateNode;
    reactProdInvariant("33");
  }
  function getFiberCurrentPropsFromNode$1(node) {
    return node[internalEventHandlersKey] || null;
  }
  function updateFiberProps(node, props) {
    node[internalEventHandlersKey] = props;
  }
  function getParent(inst) {
    do inst = inst.return;
    while (inst && 5 !== inst.tag);
    return inst ? inst : null;
  }
  function traverseTwoPhase(inst, fn, arg) {
    for (var path = []; inst; ) path.push(inst), (inst = getParent(inst));
    for (inst = path.length; 0 < inst--; ) fn(path[inst], "captured", arg);
    for (inst = 0; inst < path.length; inst++) fn(path[inst], "bubbled", arg);
  }
  function accumulateDirectionalDispatches(inst, phase, event) {
    if (
      (phase = getListener(
        inst,
        event.dispatchConfig.phasedRegistrationNames[phase]
      ))
    )
      (event._dispatchListeners = accumulateInto(
        event._dispatchListeners,
        phase
      )),
        (event._dispatchInstances = accumulateInto(
          event._dispatchInstances,
          inst
        ));
  }
  function accumulateTwoPhaseDispatchesSingle(event) {
    event &&
      event.dispatchConfig.phasedRegistrationNames &&
      traverseTwoPhase(
        event._targetInst,
        accumulateDirectionalDispatches,
        event
      );
  }
  function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
    if (event && event.dispatchConfig.phasedRegistrationNames) {
      var targetInst = event._targetInst;
      targetInst = targetInst ? getParent(targetInst) : null;
      traverseTwoPhase(targetInst, accumulateDirectionalDispatches, event);
    }
  }
  function accumulateDispatches(inst, ignoredDirection, event) {
    inst &&
      event &&
      event.dispatchConfig.registrationName &&
      (ignoredDirection = getListener(
        inst,
        event.dispatchConfig.registrationName
      )) &&
      ((event._dispatchListeners = accumulateInto(
        event._dispatchListeners,
        ignoredDirection
      )),
      (event._dispatchInstances = accumulateInto(
        event._dispatchInstances,
        inst
      )));
  }
  function accumulateDirectDispatchesSingle(event) {
    event &&
      event.dispatchConfig.registrationName &&
      accumulateDispatches(event._targetInst, null, event);
  }
  function accumulateTwoPhaseDispatches(events) {
    forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
  }
  function accumulateEnterLeaveDispatches(leave, enter, from, to) {
    if (from && to)
      a: {
        var JSCompiler_temp = from;
        for (
          var instB = to, depthA = 0, tempA = JSCompiler_temp;
          tempA;
          tempA = getParent(tempA)
        )
          depthA++;
        tempA = 0;
        for (var tempB = instB; tempB; tempB = getParent(tempB)) tempA++;
        for (; 0 < depthA - tempA; )
          (JSCompiler_temp = getParent(JSCompiler_temp)), depthA--;
        for (; 0 < tempA - depthA; ) (instB = getParent(instB)), tempA--;
        for (; depthA--; ) {
          if (JSCompiler_temp === instB || JSCompiler_temp === instB.alternate)
            break a;
          JSCompiler_temp = getParent(JSCompiler_temp);
          instB = getParent(instB);
        }
        JSCompiler_temp = null;
      }
    else JSCompiler_temp = null;
    instB = JSCompiler_temp;
    for (JSCompiler_temp = []; from && from !== instB; ) {
      depthA = from.alternate;
      if (null !== depthA && depthA === instB) break;
      JSCompiler_temp.push(from);
      from = getParent(from);
    }
    for (from = []; to && to !== instB; ) {
      depthA = to.alternate;
      if (null !== depthA && depthA === instB) break;
      from.push(to);
      to = getParent(to);
    }
    for (to = 0; to < JSCompiler_temp.length; to++)
      accumulateDispatches(JSCompiler_temp[to], "bubbled", leave);
    for (leave = from.length; 0 < leave--; )
      accumulateDispatches(from[leave], "captured", enter);
  }
  function makePrefixMap(styleProp, eventName) {
    var prefixes = {};
    prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
    prefixes["Webkit" + styleProp] = "webkit" + eventName;
    prefixes["Moz" + styleProp] = "moz" + eventName;
    return prefixes;
  }
  function getVendorPrefixedEventName(eventName) {
    if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
    if (!vendorPrefixes[eventName]) return eventName;
    var prefixMap = vendorPrefixes[eventName],
      styleProp;
    for (styleProp in prefixMap)
      if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
        return (prefixedEventNames[eventName] = prefixMap[styleProp]);
    return eventName;
  }
  function getTextContentAccessor() {
    !contentKey &&
      canUseDOM &&
      (contentKey =
        "textContent" in document.documentElement
          ? "textContent"
          : "innerText");
    return contentKey;
  }
  function getData() {
    if (compositionState._fallbackText) return compositionState._fallbackText;
    var start,
      startValue = compositionState._startText,
      startLength = startValue.length,
      end,
      endValue = getText(),
      endLength = endValue.length;
    for (
      start = 0;
      start < startLength && startValue[start] === endValue[start];
      start++
    );
    var minEnd = startLength - start;
    for (
      end = 1;
      end <= minEnd &&
      startValue[startLength - end] === endValue[endLength - end];
      end++
    );
    compositionState._fallbackText = endValue.slice(
      start,
      1 < end ? 1 - end : void 0
    );
    return compositionState._fallbackText;
  }
  function getText() {
    return "value" in compositionState._root
      ? compositionState._root.value
      : compositionState._root[getTextContentAccessor()];
  }
  function functionThatReturnsTrue() {
    return !0;
  }
  function functionThatReturnsFalse() {
    return !1;
  }
  function SyntheticEvent(
    dispatchConfig,
    targetInst,
    nativeEvent,
    nativeEventTarget
  ) {
    this.dispatchConfig = dispatchConfig;
    this._targetInst = targetInst;
    this.nativeEvent = nativeEvent;
    dispatchConfig = this.constructor.Interface;
    for (var propName in dispatchConfig)
      dispatchConfig.hasOwnProperty(propName) &&
        ((targetInst = dispatchConfig[propName])
          ? (this[propName] = targetInst(nativeEvent))
          : "target" === propName
            ? (this.target = nativeEventTarget)
            : (this[propName] = nativeEvent[propName]));
    this.isDefaultPrevented = (null != nativeEvent.defaultPrevented
    ? nativeEvent.defaultPrevented
    : !1 === nativeEvent.returnValue)
      ? functionThatReturnsTrue
      : functionThatReturnsFalse;
    this.isPropagationStopped = functionThatReturnsFalse;
    return this;
  }
  function extend(Class, Interface) {
    Class.Interface = _assign({}, Interface, Class.Interface);
    addEventPoolingTo(Class);
  }
  function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
    if (this.eventPool.length) {
      var instance = this.eventPool.pop();
      this.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
      return instance;
    }
    return new this(dispatchConfig, targetInst, nativeEvent, nativeInst);
  }
  function releasePooledEvent(event) {
    event instanceof this
      ? void 0
      : invariant(
          !1,
          "Trying to release an event instance into a pool of a different type."
        );
    event.destructor();
    10 > this.eventPool.length && this.eventPool.push(event);
  }
  function addEventPoolingTo(EventConstructor) {
    EventConstructor.eventPool = [];
    EventConstructor.getPooled = getPooledEvent;
    EventConstructor.release = releasePooledEvent;
  }
  function isFallbackCompositionEnd(topLevelType, nativeEvent) {
    switch (topLevelType) {
      case "keyup":
        return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
      case "keydown":
        return 229 !== nativeEvent.keyCode;
      case "keypress":
      case "mousedown":
      case "blur":
        return !0;
      default:
        return !1;
    }
  }
  function getDataFromCustomEvent(nativeEvent) {
    nativeEvent = nativeEvent.detail;
    return "object" === typeof nativeEvent && "data" in nativeEvent
      ? nativeEvent.data
      : null;
  }
  function getNativeBeforeInputChars(topLevelType, nativeEvent) {
    switch (topLevelType) {
      case "compositionend":
        return getDataFromCustomEvent(nativeEvent);
      case "keypress":
        if (32 !== nativeEvent.which) return null;
        hasSpaceKeypress = !0;
        return SPACEBAR_CHAR;
      case "textInput":
        return (
          (topLevelType = nativeEvent.data),
          topLevelType === SPACEBAR_CHAR && hasSpaceKeypress
            ? null
            : topLevelType
        );
      default:
        return null;
    }
  }
  function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
    if (isComposing)
      return "compositionend" === topLevelType ||
        (!canUseCompositionEvent &&
          isFallbackCompositionEnd(topLevelType, nativeEvent))
        ? ((topLevelType = getData()),
          (compositionState._root = null),
          (compositionState._startText = null),
          (compositionState._fallbackText = null),
          (isComposing = !1),
          topLevelType)
        : null;
    switch (topLevelType) {
      case "paste":
        return null;
      case "keypress":
        if (
          !(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) ||
          (nativeEvent.ctrlKey && nativeEvent.altKey)
        ) {
          if (nativeEvent.char && 1 < nativeEvent.char.length)
            return nativeEvent.char;
          if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
        }
        return null;
      case "compositionend":
        return useFallbackCompositionData && "ko" !== nativeEvent.locale
          ? null
          : nativeEvent.data;
      default:
        return null;
    }
  }
  function restoreStateOfTarget(target) {
    if ((target = getInstanceFromNode(target))) {
      fiberHostComponent &&
      "function" === typeof fiberHostComponent.restoreControlledState
        ? void 0
        : reactProdInvariant("194");
      var props = getFiberCurrentPropsFromNode(target.stateNode);
      fiberHostComponent.restoreControlledState(
        target.stateNode,
        target.type,
        props
      );
    }
  }
  function enqueueStateRestore(target) {
    restoreTarget
      ? restoreQueue
        ? restoreQueue.push(target)
        : (restoreQueue = [target])
      : (restoreTarget = target);
  }
  function needsStateRestore() {
    return null !== restoreTarget || null !== restoreQueue;
  }
  function restoreStateIfNeeded() {
    if (restoreTarget) {
      var target = restoreTarget,
        queuedTargets = restoreQueue;
      restoreQueue = restoreTarget = null;
      restoreStateOfTarget(target);
      if (queuedTargets)
        for (target = 0; target < queuedTargets.length; target++)
          restoreStateOfTarget(queuedTargets[target]);
    }
  }
  function batchedUpdates(fn, bookkeeping) {
    if (isBatching) return fn(bookkeeping);
    isBatching = !0;
    try {
      return _batchedUpdates(fn, bookkeeping);
    } finally {
      (isBatching = !1),
        needsStateRestore() &&
          (_flushInteractiveUpdates(), restoreStateIfNeeded());
    }
  }
  function isTextInputElement(elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return "input" === nodeName
      ? !!supportedInputTypes[elem.type]
      : "textarea" === nodeName
        ? !0
        : !1;
  }
  function getEventTarget(nativeEvent) {
    nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
    nativeEvent.correspondingUseElement &&
      (nativeEvent = nativeEvent.correspondingUseElement);
    return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
  }
  function isEventSupported(eventNameSuffix, capture) {
    if (!canUseDOM || (capture && !("addEventListener" in document))) return !1;
    eventNameSuffix = "on" + eventNameSuffix;
    capture = eventNameSuffix in document;
    capture ||
      ((capture = document.createElement("div")),
      capture.setAttribute(eventNameSuffix, "return;"),
      (capture = "function" === typeof capture[eventNameSuffix]));
    return capture;
  }
  function isCheckable(elem) {
    var type = elem.type;
    return (
      (elem = elem.nodeName) &&
      "input" === elem.toLowerCase() &&
      ("checkbox" === type || "radio" === type)
    );
  }
  function trackValueOnNode(node) {
    var valueField = isCheckable(node) ? "checked" : "value",
      descriptor = Object.getOwnPropertyDescriptor(
        node.constructor.prototype,
        valueField
      ),
      currentValue = "" + node[valueField];
    if (
      !node.hasOwnProperty(valueField) &&
      "undefined" !== typeof descriptor &&
      "function" === typeof descriptor.get &&
      "function" === typeof descriptor.set
    ) {
      var get = descriptor.get,
        set = descriptor.set;
      Object.defineProperty(node, valueField, {
        configurable: !0,
        get: function() {
          return get.call(this);
        },
        set: function(value) {
          currentValue = "" + value;
          set.call(this, value);
        }
      });
      Object.defineProperty(node, valueField, {
        enumerable: descriptor.enumerable
      });
      return {
        getValue: function() {
          return currentValue;
        },
        setValue: function(value) {
          currentValue = "" + value;
        },
        stopTracking: function() {
          node._valueTracker = null;
          delete node[valueField];
        }
      };
    }
  }
  function track(node) {
    node._valueTracker || (node._valueTracker = trackValueOnNode(node));
  }
  function updateValueIfChanged(node) {
    if (!node) return !1;
    var tracker = node._valueTracker;
    if (!tracker) return !0;
    var lastValue = tracker.getValue();
    var value = "";
    node &&
      (value = isCheckable(node)
        ? node.checked
          ? "true"
          : "false"
        : node.value);
    node = value;
    return node !== lastValue ? (tracker.setValue(node), !0) : !1;
  }
  function getIteratorFn(maybeIterable) {
    if (null === maybeIterable || "undefined" === typeof maybeIterable)
      return null;
    maybeIterable =
      (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
      maybeIterable["@@iterator"];
    return "function" === typeof maybeIterable ? maybeIterable : null;
  }
  function getComponentName(type) {
    if (null == type) return null;
    if ("function" === typeof type)
      return type.displayName || type.name || null;
    if ("string" === typeof type) return type;
    switch (type) {
      case REACT_ASYNC_MODE_TYPE:
        return "AsyncMode";
      case REACT_FRAGMENT_TYPE:
        return "Fragment";
      case REACT_PORTAL_TYPE:
        return "Portal";
      case REACT_PROFILER_TYPE:
        return "Profiler";
      case REACT_STRICT_MODE_TYPE:
        return "StrictMode";
      case REACT_PLACEHOLDER_TYPE:
        return "Placeholder";
    }
    if ("object" === typeof type)
      switch (type.$$typeof) {
        case REACT_CONTEXT_TYPE:
          return "Context.Consumer";
        case REACT_PROVIDER_TYPE:
          return "Context.Provider";
        case REACT_FORWARD_REF_TYPE:
          return (
            (type = type.render),
            (type = type.displayName || type.name || ""),
            "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"
          );
      }
    return null;
  }
  function getStackByFiberInDevAndProd(workInProgress) {
    var info = "";
    do {
      a: switch (workInProgress.tag) {
        case 0:
        case 1:
        case 2:
        case 5:
        case 11:
          var owner = workInProgress._debugOwner,
            source = workInProgress._debugSource;
          var JSCompiler_inline_result = getComponentName(workInProgress.type);
          var ownerName = null;
          owner && (ownerName = getComponentName(owner.type));
          owner = source;
          JSCompiler_inline_result =
            "\n    in " +
            (JSCompiler_inline_result || "Unknown") +
            (owner
              ? " (at " +
                owner.fileName.replace(/^.*[\\\/]/, "") +
                ":" +
                owner.lineNumber +
                ")"
              : ownerName
                ? " (created by " + ownerName + ")"
                : "");
          break a;
        default:
          JSCompiler_inline_result = "";
      }
      info += JSCompiler_inline_result;
      workInProgress = workInProgress.return;
    } while (workInProgress);
    return info;
  }
  function isAttributeNameSafe(attributeName) {
    if (validatedAttributeNameCache.hasOwnProperty(attributeName)) return !0;
    if (illegalAttributeNameCache.hasOwnProperty(attributeName)) return !1;
    if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
      return (validatedAttributeNameCache[attributeName] = !0);
    illegalAttributeNameCache[attributeName] = !0;
    return !1;
  }
  function shouldRemoveAttributeWithWarning(
    name,
    value,
    propertyInfo,
    isCustomComponentTag
  ) {
    if (null !== propertyInfo && 0 === propertyInfo.type) return !1;
    switch (typeof value) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        if (isCustomComponentTag) return !1;
        if (null !== propertyInfo) return !propertyInfo.acceptsBooleans;
        name = name.toLowerCase().slice(0, 5);
        return "data-" !== name && "aria-" !== name;
      default:
        return !1;
    }
  }
  function shouldRemoveAttribute(
    name,
    value,
    propertyInfo,
    isCustomComponentTag
  ) {
    if (
      null === value ||
      "undefined" === typeof value ||
      shouldRemoveAttributeWithWarning(
        name,
        value,
        propertyInfo,
        isCustomComponentTag
      )
    )
      return !0;
    if (isCustomComponentTag) return !1;
    if (null !== propertyInfo)
      switch (propertyInfo.type) {
        case 3:
          return !value;
        case 4:
          return !1 === value;
        case 5:
          return isNaN(value);
        case 6:
          return isNaN(value) || 1 > value;
      }
    return !1;
  }
  function PropertyInfoRecord(
    name,
    type,
    mustUseProperty,
    attributeName,
    attributeNamespace
  ) {
    this.acceptsBooleans = 2 === type || 3 === type || 4 === type;
    this.attributeName = attributeName;
    this.attributeNamespace = attributeNamespace;
    this.mustUseProperty = mustUseProperty;
    this.propertyName = name;
    this.type = type;
  }
  function setValueForProperty(node, name, value, isCustomComponentTag) {
    var propertyInfo = properties.hasOwnProperty(name)
      ? properties[name]
      : null;
    var JSCompiler_inline_result =
      null !== propertyInfo
        ? 0 === propertyInfo.type
        : isCustomComponentTag
          ? !1
          : !(2 < name.length) ||
            ("o" !== name[0] && "O" !== name[0]) ||
            ("n" !== name[1] && "N" !== name[1])
            ? !1
            : !0;
    JSCompiler_inline_result ||
      (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) &&
        (value = null),
      isCustomComponentTag || null === propertyInfo
        ? isAttributeNameSafe(name) &&
          (null === value
            ? node.removeAttribute(name)
            : node.setAttribute(name, "" + value))
        : propertyInfo.mustUseProperty
          ? (node[propertyInfo.propertyName] =
              null === value ? (3 === propertyInfo.type ? !1 : "") : value)
          : ((name = propertyInfo.attributeName),
            (isCustomComponentTag = propertyInfo.attributeNamespace),
            null === value
              ? node.removeAttribute(name)
              : ((propertyInfo = propertyInfo.type),
                (value =
                  3 === propertyInfo || (4 === propertyInfo && !0 === value)
                    ? ""
                    : "" + value),
                isCustomComponentTag
                  ? node.setAttributeNS(isCustomComponentTag, name, value)
                  : node.setAttribute(name, value))));
  }
  function getHostProps(element, props) {
    var checked = props.checked;
    return _assign({}, props, {
      defaultChecked: void 0,
      defaultValue: void 0,
      value: void 0,
      checked: null != checked ? checked : element._wrapperState.initialChecked
    });
  }
  function initWrapperState(element, props) {
    var defaultValue = null == props.defaultValue ? "" : props.defaultValue,
      JSCompiler_temp_const =
        null != props.checked ? props.checked : props.defaultChecked;
    defaultValue = getSafeValue(
      null != props.value ? props.value : defaultValue
    );
    element._wrapperState = {
      initialChecked: JSCompiler_temp_const,
      initialValue: defaultValue,
      controlled:
        "checkbox" === props.type || "radio" === props.type
          ? null != props.checked
          : null != props.value
    };
  }
  function updateChecked(element, props) {
    props = props.checked;
    null != props && setValueForProperty(element, "checked", props, !1);
  }
  function updateWrapper(element, props) {
    updateChecked(element, props);
    var value = getSafeValue(props.value);
    if (null != value)
      if ("number" === props.type) {
        if ((0 === value && "" === element.value) || element.value != value)
          element.value = "" + value;
      } else element.value !== "" + value && (element.value = "" + value);
    props.hasOwnProperty("value")
      ? setDefaultValue(element, props.type, value)
      : props.hasOwnProperty("defaultValue") &&
        setDefaultValue(element, props.type, getSafeValue(props.defaultValue));
    null == props.checked &&
      null != props.defaultChecked &&
      (element.defaultChecked = !!props.defaultChecked);
  }
  function postMountWrapper(element, props, isHydrating) {
    if (props.hasOwnProperty("value") || props.hasOwnProperty("defaultValue")) {
      props = "" + element._wrapperState.initialValue;
      var currentValue = element.value;
      isHydrating || props === currentValue || (element.value = props);
      element.defaultValue = props;
    }
    isHydrating = element.name;
    "" !== isHydrating && (element.name = "");
    element.defaultChecked = !element.defaultChecked;
    element.defaultChecked = !!element._wrapperState.initialChecked;
    "" !== isHydrating && (element.name = isHydrating);
  }
  function setDefaultValue(node, type, value) {
    if ("number" !== type || node.ownerDocument.activeElement !== node)
      null == value
        ? (node.defaultValue = "" + node._wrapperState.initialValue)
        : node.defaultValue !== "" + value && (node.defaultValue = "" + value);
  }
  function getSafeValue(value) {
    switch (typeof value) {
      case "boolean":
      case "number":
      case "object":
      case "string":
      case "undefined":
        return value;
      default:
        return "";
    }
  }
  function createAndAccumulateChangeEvent(inst, nativeEvent, target) {
    inst = SyntheticEvent.getPooled(
      eventTypes$1.change,
      inst,
      nativeEvent,
      target
    );
    inst.type = "change";
    enqueueStateRestore(target);
    accumulateTwoPhaseDispatches(inst);
    return inst;
  }
  function runEventInBatch(event) {
    runEventsInBatch(event, !1);
  }
  function getInstIfValueChanged(targetInst) {
    var targetNode = getNodeFromInstance$1(targetInst);
    if (updateValueIfChanged(targetNode)) return targetInst;
  }
  function getTargetInstForChangeEvent(topLevelType, targetInst) {
    if ("change" === topLevelType) return targetInst;
  }
  function stopWatchingForValueChange() {
    activeElement &&
      (activeElement.detachEvent("onpropertychange", handlePropertyChange),
      (activeElementInst = activeElement = null));
  }
  function handlePropertyChange(nativeEvent) {
    "value" === nativeEvent.propertyName &&
      getInstIfValueChanged(activeElementInst) &&
      ((nativeEvent = createAndAccumulateChangeEvent(
        activeElementInst,
        nativeEvent,
        getEventTarget(nativeEvent)
      )),
      batchedUpdates(runEventInBatch, nativeEvent));
  }
  function handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {
    "focus" === topLevelType
      ? (stopWatchingForValueChange(),
        (activeElement = target),
        (activeElementInst = targetInst),
        activeElement.attachEvent("onpropertychange", handlePropertyChange))
      : "blur" === topLevelType && stopWatchingForValueChange();
  }
  function getTargetInstForInputEventPolyfill(topLevelType, targetInst) {
    if (
      "selectionchange" === topLevelType ||
      "keyup" === topLevelType ||
      "keydown" === topLevelType
    )
      return getInstIfValueChanged(activeElementInst);
  }
  function getTargetInstForClickEvent(topLevelType, targetInst) {
    if ("click" === topLevelType) return getInstIfValueChanged(targetInst);
  }
  function getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {
    if ("input" === topLevelType || "change" === topLevelType)
      return getInstIfValueChanged(targetInst);
  }
  function modifierStateGetter(keyArg) {
    var nativeEvent = this.nativeEvent;
    return nativeEvent.getModifierState
      ? nativeEvent.getModifierState(keyArg)
      : (keyArg = modifierKeyToProp[keyArg])
        ? !!nativeEvent[keyArg]
        : !1;
  }
  function getEventModifierState(nativeEvent) {
    return modifierStateGetter;
  }
  function is(x, y) {
    return x === y ? 0 !== x || 0 !== y || 1 / x === 1 / y : x !== x && y !== y;
  }
  function shallowEqual(objA, objB) {
    if (is(objA, objB)) return !0;
    if (
      "object" !== typeof objA ||
      null === objA ||
      "object" !== typeof objB ||
      null === objB
    )
      return !1;
    var keysA = Object.keys(objA),
      keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) return !1;
    for (keysB = 0; keysB < keysA.length; keysB++)
      if (
        !hasOwnProperty.call(objB, keysA[keysB]) ||
        !is(objA[keysA[keysB]], objB[keysA[keysB]])
      )
        return !1;
    return !0;
  }
  function isFiberMountedImpl(fiber) {
    var node = fiber;
    if (fiber.alternate) for (; node.return; ) node = node.return;
    else {
      if (0 !== (node.effectTag & 2)) return 1;
      for (; node.return; )
        if (((node = node.return), 0 !== (node.effectTag & 2))) return 1;
    }
    return 3 === node.tag ? 2 : 3;
  }
  function assertIsMounted(fiber) {
    2 !== isFiberMountedImpl(fiber) ? reactProdInvariant("188") : void 0;
  }
  function findCurrentFiberUsingSlowPath(fiber) {
    var alternate = fiber.alternate;
    if (!alternate)
      return (
        (alternate = isFiberMountedImpl(fiber)),
        3 === alternate ? reactProdInvariant("188") : void 0,
        1 === alternate ? null : fiber
      );
    for (var a = fiber, b = alternate; ; ) {
      var parentA = a.return,
        parentB = parentA ? parentA.alternate : null;
      if (!parentA || !parentB) break;
      if (parentA.child === parentB.child) {
        for (var child = parentA.child; child; ) {
          if (child === a) return assertIsMounted(parentA), fiber;
          if (child === b) return assertIsMounted(parentA), alternate;
          child = child.sibling;
        }
        reactProdInvariant("188");
      }
      if (a.return !== b.return) (a = parentA), (b = parentB);
      else {
        child = !1;
        for (var _child = parentA.child; _child; ) {
          if (_child === a) {
            child = !0;
            a = parentA;
            b = parentB;
            break;
          }
          if (_child === b) {
            child = !0;
            b = parentA;
            a = parentB;
            break;
          }
          _child = _child.sibling;
        }
        if (!child) {
          for (_child = parentB.child; _child; ) {
            if (_child === a) {
              child = !0;
              a = parentB;
              b = parentA;
              break;
            }
            if (_child === b) {
              child = !0;
              b = parentB;
              a = parentA;
              break;
            }
            _child = _child.sibling;
          }
          child ? void 0 : reactProdInvariant("189");
        }
      }
      a.alternate !== b ? reactProdInvariant("190") : void 0;
    }
    3 !== a.tag ? reactProdInvariant("188") : void 0;
    return a.stateNode.current === a ? fiber : alternate;
  }
  function findCurrentHostFiber(parent) {
    parent = findCurrentFiberUsingSlowPath(parent);
    if (!parent) return null;
    for (var node = parent; ; ) {
      if (5 === node.tag || 6 === node.tag) return node;
      if (node.child) (node.child.return = node), (node = node.child);
      else {
        if (node === parent) break;
        for (; !node.sibling; ) {
          if (!node.return || node.return === parent) return null;
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
    }
    return null;
  }
  function findCurrentHostFiberWithNoPortals(parent) {
    parent = findCurrentFiberUsingSlowPath(parent);
    if (!parent) return null;
    for (var node = parent; ; ) {
      if (5 === node.tag || 6 === node.tag) return node;
      if (node.child && 4 !== node.tag)
        (node.child.return = node), (node = node.child);
      else {
        if (node === parent) break;
        for (; !node.sibling; ) {
          if (!node.return || node.return === parent) return null;
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
    }
    return null;
  }
  function getEventCharCode(nativeEvent) {
    var keyCode = nativeEvent.keyCode;
    "charCode" in nativeEvent
      ? ((nativeEvent = nativeEvent.charCode),
        0 === nativeEvent && 13 === keyCode && (nativeEvent = 13))
      : (nativeEvent = keyCode);
    10 === nativeEvent && (nativeEvent = 13);
    return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
  }
  function addEventTypeNameToConfig(_ref, isInteractive) {
    var topEvent = _ref[0];
    _ref = _ref[1];
    var onEvent = "on" + (_ref[0].toUpperCase() + _ref.slice(1));
    isInteractive = {
      phasedRegistrationNames: {
        bubbled: onEvent,
        captured: onEvent + "Capture"
      },
      dependencies: [topEvent],
      isInteractive: isInteractive
    };
    eventTypes$4[_ref] = isInteractive;
    topLevelEventsToDispatchConfig[topEvent] = isInteractive;
  }
  function handleTopLevel(bookKeeping) {
    var targetInst = bookKeeping.targetInst;
    do {
      if (!targetInst) {
        bookKeeping.ancestors.push(targetInst);
        break;
      }
      var root;
      for (root = targetInst; root.return; ) root = root.return;
      root = 3 !== root.tag ? null : root.stateNode.containerInfo;
      if (!root) break;
      bookKeeping.ancestors.push(targetInst);
      targetInst = getClosestInstanceFromNode(root);
    } while (targetInst);
    for (root = 0; root < bookKeeping.ancestors.length; root++)
      (targetInst = bookKeeping.ancestors[root]),
        runExtractedEventsInBatch(
          bookKeeping.topLevelType,
          targetInst,
          bookKeeping.nativeEvent,
          getEventTarget(bookKeeping.nativeEvent)
        );
  }
  function setEnabled(enabled) {
    _enabled = !!enabled;
  }
  function trapBubbledEvent(topLevelType, element) {
    if (!element) return null;
    var listener = (isInteractiveTopLevelEventType(topLevelType)
      ? dispatchInteractiveEvent
      : dispatchEvent
    ).bind(null, topLevelType);
    element.addEventListener(topLevelType, listener, !1);
  }
  function trapCapturedEvent(topLevelType, element) {
    if (!element) return null;
    var listener = (isInteractiveTopLevelEventType(topLevelType)
      ? dispatchInteractiveEvent
      : dispatchEvent
    ).bind(null, topLevelType);
    element.addEventListener(topLevelType, listener, !0);
  }
  function dispatchInteractiveEvent(topLevelType, nativeEvent) {
    _interactiveUpdates(dispatchEvent, topLevelType, nativeEvent);
  }
  function dispatchEvent(topLevelType, nativeEvent) {
    if (_enabled) {
      var nativeEventTarget = getEventTarget(nativeEvent);
      nativeEventTarget = getClosestInstanceFromNode(nativeEventTarget);
      null === nativeEventTarget ||
        "number" !== typeof nativeEventTarget.tag ||
        2 === isFiberMountedImpl(nativeEventTarget) ||
        (nativeEventTarget = null);
      if (callbackBookkeepingPool.length) {
        var instance = callbackBookkeepingPool.pop();
        instance.topLevelType = topLevelType;
        instance.nativeEvent = nativeEvent;
        instance.targetInst = nativeEventTarget;
        topLevelType = instance;
      } else
        topLevelType = {
          topLevelType: topLevelType,
          nativeEvent: nativeEvent,
          targetInst: nativeEventTarget,
          ancestors: []
        };
      try {
        batchedUpdates(handleTopLevel, topLevelType);
      } finally {
        (topLevelType.topLevelType = null),
          (topLevelType.nativeEvent = null),
          (topLevelType.targetInst = null),
          (topLevelType.ancestors.length = 0),
          10 > callbackBookkeepingPool.length &&
            callbackBookkeepingPool.push(topLevelType);
      }
    }
  }
  function getListeningForDocument(mountAt) {
    Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey) ||
      ((mountAt[topListenersIDKey] = reactTopListenersCounter++),
      (alreadyListeningTo[mountAt[topListenersIDKey]] = {}));
    return alreadyListeningTo[mountAt[topListenersIDKey]];
  }
  function getActiveElement(doc) {
    doc = doc || ("undefined" !== typeof document ? document : void 0);
    if ("undefined" === typeof doc) return null;
    try {
      return doc.activeElement || doc.body;
    } catch (e) {
      return doc.body;
    }
  }
  function getLeafNode(node) {
    for (; node && node.firstChild; ) node = node.firstChild;
    return node;
  }
  function getNodeForCharacterOffset(root, offset) {
    var node = getLeafNode(root);
    root = 0;
    for (var nodeEnd; node; ) {
      if (3 === node.nodeType) {
        nodeEnd = root + node.textContent.length;
        if (root <= offset && nodeEnd >= offset)
          return { node: node, offset: offset - root };
        root = nodeEnd;
      }
      a: {
        for (; node; ) {
          if (node.nextSibling) {
            node = node.nextSibling;
            break a;
          }
          node = node.parentNode;
        }
        node = void 0;
      }
      node = getLeafNode(node);
    }
  }
  function isTextNode(object) {
    var defaultView =
      (object ? object.ownerDocument || object : document).defaultView ||
      window;
    return (
      !!(
        object &&
        ("function" === typeof defaultView.Node
          ? object instanceof defaultView.Node
          : "object" === typeof object &&
            "number" === typeof object.nodeType &&
            "string" === typeof object.nodeName)
      ) && 3 === object.nodeType
    );
  }
  function containsNode(outerNode, innerNode) {
    return outerNode && innerNode
      ? outerNode === innerNode
        ? !0
        : isTextNode(outerNode)
          ? !1
          : isTextNode(innerNode)
            ? containsNode(outerNode, innerNode.parentNode)
            : "contains" in outerNode
              ? outerNode.contains(innerNode)
              : outerNode.compareDocumentPosition
                ? !!(outerNode.compareDocumentPosition(innerNode) & 16)
                : !1
      : !1;
  }
  function hasSelectionCapabilities(elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return (
      nodeName &&
      (("input" === nodeName &&
        ("text" === elem.type ||
          "search" === elem.type ||
          "tel" === elem.type ||
          "url" === elem.type ||
          "password" === elem.type)) ||
        "textarea" === nodeName ||
        "true" === elem.contentEditable)
    );
  }
  function constructSelectEvent(nativeEvent, nativeEventTarget) {
    if (
      mouseDown ||
      null == activeElement$1 ||
      activeElement$1 !== getActiveElement()
    )
      return null;
    var currentSelection = activeElement$1;
    "selectionStart" in currentSelection &&
    hasSelectionCapabilities(currentSelection)
      ? (currentSelection = {
          start: currentSelection.selectionStart,
          end: currentSelection.selectionEnd
        })
      : window.getSelection
        ? ((currentSelection = window.getSelection()),
          (currentSelection = {
            anchorNode: currentSelection.anchorNode,
            anchorOffset: currentSelection.anchorOffset,
            focusNode: currentSelection.focusNode,
            focusOffset: currentSelection.focusOffset
          }))
        : (currentSelection = void 0);
    return lastSelection && shallowEqual(lastSelection, currentSelection)
      ? null
      : ((lastSelection = currentSelection),
        (nativeEvent = SyntheticEvent.getPooled(
          eventTypes$3.select,
          activeElementInst$1,
          nativeEvent,
          nativeEventTarget
        )),
        (nativeEvent.type = "select"),
        (nativeEvent.target = activeElement$1),
        accumulateTwoPhaseDispatches(nativeEvent),
        nativeEvent);
  }
  function flattenChildren(children) {
    var content = "";
    React.Children.forEach(children, function(child) {
      null == child ||
        ("string" !== typeof child && "number" !== typeof child) ||
        (content += child);
    });
    return content;
  }
  function getHostProps$1(element, props) {
    element = _assign({ children: void 0 }, props);
    if ((props = flattenChildren(props.children))) element.children = props;
    return element;
  }
  function updateOptions(node, multiple, propValue, setDefaultSelected) {
    node = node.options;
    if (multiple) {
      multiple = {};
      for (var i = 0; i < propValue.length; i++)
        multiple["$" + propValue[i]] = !0;
      for (propValue = 0; propValue < node.length; propValue++)
        (i = multiple.hasOwnProperty("$" + node[propValue].value)),
          node[propValue].selected !== i && (node[propValue].selected = i),
          i && setDefaultSelected && (node[propValue].defaultSelected = !0);
    } else {
      propValue = "" + propValue;
      multiple = null;
      for (i = 0; i < node.length; i++) {
        if (node[i].value === propValue) {
          node[i].selected = !0;
          setDefaultSelected && (node[i].defaultSelected = !0);
          return;
        }
        null !== multiple || node[i].disabled || (multiple = node[i]);
      }
      null !== multiple && (multiple.selected = !0);
    }
  }
  function initWrapperState$1(element, props) {
    var value = props.value;
    element._wrapperState = {
      initialValue: null != value ? value : props.defaultValue,
      wasMultiple: !!props.multiple
    };
  }
  function getHostProps$3(element, props) {
    null != props.dangerouslySetInnerHTML ? reactProdInvariant("91") : void 0;
    return _assign({}, props, {
      value: void 0,
      defaultValue: void 0,
      children: "" + element._wrapperState.initialValue
    });
  }
  function initWrapperState$2(element, props) {
    var initialValue = props.value;
    null == initialValue &&
      ((initialValue = props.defaultValue),
      (props = props.children),
      null != props &&
        (null != initialValue ? reactProdInvariant("92") : void 0,
        Array.isArray(props) &&
          (1 >= props.length ? void 0 : reactProdInvariant("93"),
          (props = props[0])),
        (initialValue = "" + props)),
      null == initialValue && (initialValue = ""));
    element._wrapperState = { initialValue: "" + initialValue };
  }
  function updateWrapper$1(element, props) {
    var value = props.value;
    null != value &&
      ((value = "" + value),
      value !== element.value && (element.value = value),
      null == props.defaultValue && (element.defaultValue = value));
    null != props.defaultValue && (element.defaultValue = props.defaultValue);
  }
  function getIntrinsicNamespace(type) {
    switch (type) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function getChildNamespace(parentNamespace, type) {
    return null == parentNamespace ||
      "http://www.w3.org/1999/xhtml" === parentNamespace
      ? getIntrinsicNamespace(type)
      : "http://www.w3.org/2000/svg" === parentNamespace &&
        "foreignObject" === type
        ? "http://www.w3.org/1999/xhtml"
        : parentNamespace;
  }
  function setValueForStyles(node, styles) {
    node = node.style;
    for (var styleName in styles)
      if (styles.hasOwnProperty(styleName)) {
        var isCustomProperty = 0 === styleName.indexOf("--");
        var styleValue = styleName;
        var value = styles[styleName];
        styleValue =
          null == value || "boolean" === typeof value || "" === value
            ? ""
            : isCustomProperty ||
              "number" !== typeof value ||
              0 === value ||
              (isUnitlessNumber.hasOwnProperty(styleValue) &&
                isUnitlessNumber[styleValue])
              ? ("" + value).trim()
              : value + "px";
        "float" === styleName && (styleName = "cssFloat");
        isCustomProperty
          ? node.setProperty(styleName, styleValue)
          : (node[styleName] = styleValue);
      }
  }
  function assertValidProps(tag, props) {
    props &&
      (voidElementTags[tag] &&
        (null != props.children || null != props.dangerouslySetInnerHTML
          ? reactProdInvariant("137", tag, "")
          : void 0),
      null != props.dangerouslySetInnerHTML &&
        (null != props.children ? reactProdInvariant("60") : void 0,
        "object" === typeof props.dangerouslySetInnerHTML &&
        "__html" in props.dangerouslySetInnerHTML
          ? void 0
          : reactProdInvariant("61")),
      null != props.style && "object" !== typeof props.style
        ? reactProdInvariant("62", "")
        : void 0);
  }
  function isCustomComponent(tagName, props) {
    if (-1 === tagName.indexOf("-")) return "string" === typeof props.is;
    switch (tagName) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  function ensureListeningTo(rootContainerElement, registrationName) {
    rootContainerElement =
      9 === rootContainerElement.nodeType ||
      11 === rootContainerElement.nodeType
        ? rootContainerElement
        : rootContainerElement.ownerDocument;
    var isListening = getListeningForDocument(rootContainerElement);
    registrationName = registrationNameDependencies[registrationName];
    for (var i = 0; i < registrationName.length; i++) {
      var dependency = registrationName[i];
      if (!isListening.hasOwnProperty(dependency) || !isListening[dependency]) {
        switch (dependency) {
          case "scroll":
            trapCapturedEvent("scroll", rootContainerElement);
            break;
          case "focus":
          case "blur":
            trapCapturedEvent("focus", rootContainerElement);
            trapCapturedEvent("blur", rootContainerElement);
            isListening.blur = !0;
            isListening.focus = !0;
            break;
          case "cancel":
          case "close":
            isEventSupported(dependency, !0) &&
              trapCapturedEvent(dependency, rootContainerElement);
            break;
          case "invalid":
          case "submit":
          case "reset":
            break;
          default:
            -1 === mediaEventTypes.indexOf(dependency) &&
              trapBubbledEvent(dependency, rootContainerElement);
        }
        isListening[dependency] = !0;
      }
    }
  }
  function noop() {}
  function createElement$1(type, props, rootContainerElement, parentNamespace) {
    rootContainerElement =
      9 === rootContainerElement.nodeType
        ? rootContainerElement
        : rootContainerElement.ownerDocument;
    "http://www.w3.org/1999/xhtml" === parentNamespace &&
      (parentNamespace = getIntrinsicNamespace(type));
    "http://www.w3.org/1999/xhtml" === parentNamespace
      ? "script" === type
        ? ((type = rootContainerElement.createElement("div")),
          (type.innerHTML = "<script>\x3c/script>"),
          (type = type.removeChild(type.firstChild)))
        : (type =
            "string" === typeof props.is
              ? rootContainerElement.createElement(type, { is: props.is })
              : rootContainerElement.createElement(type))
      : (type = rootContainerElement.createElementNS(parentNamespace, type));
    return type;
  }
  function createTextNode$1(text, rootContainerElement) {
    return (9 === rootContainerElement.nodeType
      ? rootContainerElement
      : rootContainerElement.ownerDocument
    ).createTextNode(text);
  }
  function setInitialProperties$1(
    domElement,
    tag,
    rawProps,
    rootContainerElement
  ) {
    var isCustomComponentTag = isCustomComponent(tag, rawProps);
    switch (tag) {
      case "iframe":
      case "object":
        trapBubbledEvent("load", domElement);
        var props = rawProps;
        break;
      case "video":
      case "audio":
        for (props = 0; props < mediaEventTypes.length; props++)
          trapBubbledEvent(mediaEventTypes[props], domElement);
        props = rawProps;
        break;
      case "source":
        trapBubbledEvent("error", domElement);
        props = rawProps;
        break;
      case "img":
      case "image":
      case "link":
        trapBubbledEvent("error", domElement);
        trapBubbledEvent("load", domElement);
        props = rawProps;
        break;
      case "form":
        trapBubbledEvent("reset", domElement);
        trapBubbledEvent("submit", domElement);
        props = rawProps;
        break;
      case "details":
        trapBubbledEvent("toggle", domElement);
        props = rawProps;
        break;
      case "input":
        initWrapperState(domElement, rawProps);
        props = getHostProps(domElement, rawProps);
        trapBubbledEvent("invalid", domElement);
        ensureListeningTo(rootContainerElement, "onChange");
        break;
      case "option":
        props = getHostProps$1(domElement, rawProps);
        break;
      case "select":
        initWrapperState$1(domElement, rawProps);
        props = _assign({}, rawProps, { value: void 0 });
        trapBubbledEvent("invalid", domElement);
        ensureListeningTo(rootContainerElement, "onChange");
        break;
      case "textarea":
        initWrapperState$2(domElement, rawProps);
        props = getHostProps$3(domElement, rawProps);
        trapBubbledEvent("invalid", domElement);
        ensureListeningTo(rootContainerElement, "onChange");
        break;
      default:
        props = rawProps;
    }
    assertValidProps(tag, props);
    var nextProps = props,
      propKey;
    for (propKey in nextProps)
      if (nextProps.hasOwnProperty(propKey)) {
        var nextProp = nextProps[propKey];
        "style" === propKey
          ? setValueForStyles(domElement, nextProp)
          : "dangerouslySetInnerHTML" === propKey
            ? ((nextProp = nextProp ? nextProp.__html : void 0),
              null != nextProp && setInnerHTML(domElement, nextProp))
            : "children" === propKey
              ? "string" === typeof nextProp
                ? ("textarea" !== tag || "" !== nextProp) &&
                  setTextContent(domElement, nextProp)
                : "number" === typeof nextProp &&
                  setTextContent(domElement, "" + nextProp)
              : "suppressContentEditableWarning" !== propKey &&
                "suppressHydrationWarning" !== propKey &&
                "autoFocus" !== propKey &&
                (registrationNameModules.hasOwnProperty(propKey)
                  ? null != nextProp &&
                    ensureListeningTo(rootContainerElement, propKey)
                  : null != nextProp &&
                    setValueForProperty(
                      domElement,
                      propKey,
                      nextProp,
                      isCustomComponentTag
                    ));
      }
    switch (tag) {
      case "input":
        track(domElement);
        postMountWrapper(domElement, rawProps, !1);
        break;
      case "textarea":
        track(domElement);
        rawProps = domElement.textContent;
        rawProps === domElement._wrapperState.initialValue &&
          (domElement.value = rawProps);
        break;
      case "option":
        null != rawProps.value &&
          domElement.setAttribute("value", rawProps.value);
        break;
      case "select":
        domElement.multiple = !!rawProps.multiple;
        tag = rawProps.value;
        null != tag
          ? updateOptions(domElement, !!rawProps.multiple, tag, !1)
          : null != rawProps.defaultValue &&
            updateOptions(
              domElement,
              !!rawProps.multiple,
              rawProps.defaultValue,
              !0
            );
        break;
      default:
        "function" === typeof props.onClick && (domElement.onclick = noop);
    }
  }
  function diffProperties$1(
    domElement,
    tag,
    lastRawProps,
    nextRawProps,
    rootContainerElement
  ) {
    var updatePayload = null;
    switch (tag) {
      case "input":
        lastRawProps = getHostProps(domElement, lastRawProps);
        nextRawProps = getHostProps(domElement, nextRawProps);
        updatePayload = [];
        break;
      case "option":
        lastRawProps = getHostProps$1(domElement, lastRawProps);
        nextRawProps = getHostProps$1(domElement, nextRawProps);
        updatePayload = [];
        break;
      case "select":
        lastRawProps = _assign({}, lastRawProps, { value: void 0 });
        nextRawProps = _assign({}, nextRawProps, { value: void 0 });
        updatePayload = [];
        break;
      case "textarea":
        lastRawProps = getHostProps$3(domElement, lastRawProps);
        nextRawProps = getHostProps$3(domElement, nextRawProps);
        updatePayload = [];
        break;
      default:
        "function" !== typeof lastRawProps.onClick &&
          "function" === typeof nextRawProps.onClick &&
          (domElement.onclick = noop);
    }
    assertValidProps(tag, nextRawProps);
    tag = domElement = void 0;
    var styleUpdates = null;
    for (domElement in lastRawProps)
      if (
        !nextRawProps.hasOwnProperty(domElement) &&
        lastRawProps.hasOwnProperty(domElement) &&
        null != lastRawProps[domElement]
      )
        if ("style" === domElement) {
          var lastStyle = lastRawProps[domElement];
          for (tag in lastStyle)
            lastStyle.hasOwnProperty(tag) &&
              (styleUpdates || (styleUpdates = {}), (styleUpdates[tag] = ""));
        } else
          "dangerouslySetInnerHTML" !== domElement &&
            "children" !== domElement &&
            "suppressContentEditableWarning" !== domElement &&
            "suppressHydrationWarning" !== domElement &&
            "autoFocus" !== domElement &&
            (registrationNameModules.hasOwnProperty(domElement)
              ? updatePayload || (updatePayload = [])
              : (updatePayload = updatePayload || []).push(domElement, null));
    for (domElement in nextRawProps) {
      var nextProp = nextRawProps[domElement];
      lastStyle = null != lastRawProps ? lastRawProps[domElement] : void 0;
      if (
        nextRawProps.hasOwnProperty(domElement) &&
        nextProp !== lastStyle &&
        (null != nextProp || null != lastStyle)
      )
        if ("style" === domElement)
          if (lastStyle) {
            for (tag in lastStyle)
              !lastStyle.hasOwnProperty(tag) ||
                (nextProp && nextProp.hasOwnProperty(tag)) ||
                (styleUpdates || (styleUpdates = {}), (styleUpdates[tag] = ""));
            for (tag in nextProp)
              nextProp.hasOwnProperty(tag) &&
                lastStyle[tag] !== nextProp[tag] &&
                (styleUpdates || (styleUpdates = {}),
                (styleUpdates[tag] = nextProp[tag]));
          } else
            styleUpdates ||
              (updatePayload || (updatePayload = []),
              updatePayload.push(domElement, styleUpdates)),
              (styleUpdates = nextProp);
        else
          "dangerouslySetInnerHTML" === domElement
            ? ((nextProp = nextProp ? nextProp.__html : void 0),
              (lastStyle = lastStyle ? lastStyle.__html : void 0),
              null != nextProp &&
                lastStyle !== nextProp &&
                (updatePayload = updatePayload || []).push(
                  domElement,
                  "" + nextProp
                ))
            : "children" === domElement
              ? lastStyle === nextProp ||
                ("string" !== typeof nextProp &&
                  "number" !== typeof nextProp) ||
                (updatePayload = updatePayload || []).push(
                  domElement,
                  "" + nextProp
                )
              : "suppressContentEditableWarning" !== domElement &&
                "suppressHydrationWarning" !== domElement &&
                (registrationNameModules.hasOwnProperty(domElement)
                  ? (null != nextProp &&
                      ensureListeningTo(rootContainerElement, domElement),
                    updatePayload ||
                      lastStyle === nextProp ||
                      (updatePayload = []))
                  : (updatePayload = updatePayload || []).push(
                      domElement,
                      nextProp
                    ));
    }
    styleUpdates &&
      (updatePayload = updatePayload || []).push("style", styleUpdates);
    return updatePayload;
  }
  function updateProperties$1(
    domElement,
    updatePayload,
    tag,
    lastRawProps,
    nextRawProps
  ) {
    "input" === tag &&
      "radio" === nextRawProps.type &&
      null != nextRawProps.name &&
      updateChecked(domElement, nextRawProps);
    isCustomComponent(tag, lastRawProps);
    lastRawProps = isCustomComponent(tag, nextRawProps);
    for (var i = 0; i < updatePayload.length; i += 2) {
      var propKey = updatePayload[i],
        propValue = updatePayload[i + 1];
      "style" === propKey
        ? setValueForStyles(domElement, propValue)
        : "dangerouslySetInnerHTML" === propKey
          ? setInnerHTML(domElement, propValue)
          : "children" === propKey
            ? setTextContent(domElement, propValue)
            : setValueForProperty(domElement, propKey, propValue, lastRawProps);
    }
    switch (tag) {
      case "input":
        updateWrapper(domElement, nextRawProps);
        break;
      case "textarea":
        updateWrapper$1(domElement, nextRawProps);
        break;
      case "select":
        (domElement._wrapperState.initialValue = void 0),
          (updatePayload = domElement._wrapperState.wasMultiple),
          (domElement._wrapperState.wasMultiple = !!nextRawProps.multiple),
          (tag = nextRawProps.value),
          null != tag
            ? updateOptions(domElement, !!nextRawProps.multiple, tag, !1)
            : updatePayload !== !!nextRawProps.multiple &&
              (null != nextRawProps.defaultValue
                ? updateOptions(
                    domElement,
                    !!nextRawProps.multiple,
                    nextRawProps.defaultValue,
                    !0
                  )
                : updateOptions(
                    domElement,
                    !!nextRawProps.multiple,
                    nextRawProps.multiple ? [] : "",
                    !1
                  ));
    }
  }
  function diffHydratedProperties$1(
    domElement,
    tag,
    rawProps,
    parentNamespace,
    rootContainerElement
  ) {
    switch (tag) {
      case "iframe":
      case "object":
        trapBubbledEvent("load", domElement);
        break;
      case "video":
      case "audio":
        for (
          parentNamespace = 0;
          parentNamespace < mediaEventTypes.length;
          parentNamespace++
        )
          trapBubbledEvent(mediaEventTypes[parentNamespace], domElement);
        break;
      case "source":
        trapBubbledEvent("error", domElement);
        break;
      case "img":
      case "image":
      case "link":
        trapBubbledEvent("error", domElement);
        trapBubbledEvent("load", domElement);
        break;
      case "form":
        trapBubbledEvent("reset", domElement);
        trapBubbledEvent("submit", domElement);
        break;
      case "details":
        trapBubbledEvent("toggle", domElement);
        break;
      case "input":
        initWrapperState(domElement, rawProps);
        trapBubbledEvent("invalid", domElement);
        ensureListeningTo(rootContainerElement, "onChange");
        break;
      case "select":
        initWrapperState$1(domElement, rawProps);
        trapBubbledEvent("invalid", domElement);
        ensureListeningTo(rootContainerElement, "onChange");
        break;
      case "textarea":
        initWrapperState$2(domElement, rawProps),
          trapBubbledEvent("invalid", domElement),
          ensureListeningTo(rootContainerElement, "onChange");
    }
    assertValidProps(tag, rawProps);
    parentNamespace = null;
    for (var propKey in rawProps)
      if (rawProps.hasOwnProperty(propKey)) {
        var nextProp = rawProps[propKey];
        "children" === propKey
          ? "string" === typeof nextProp
            ? domElement.textContent !== nextProp &&
              (parentNamespace = ["children", nextProp])
            : "number" === typeof nextProp &&
              domElement.textContent !== "" + nextProp &&
              (parentNamespace = ["children", "" + nextProp])
          : registrationNameModules.hasOwnProperty(propKey) &&
            null != nextProp &&
            ensureListeningTo(rootContainerElement, propKey);
      }
    switch (tag) {
      case "input":
        track(domElement);
        postMountWrapper(domElement, rawProps, !0);
        break;
      case "textarea":
        track(domElement);
        tag = domElement.textContent;
        tag === domElement._wrapperState.initialValue &&
          (domElement.value = tag);
        break;
      case "select":
      case "option":
        break;
      default:
        "function" === typeof rawProps.onClick && (domElement.onclick = noop);
    }
    return parentNamespace;
  }
  function diffHydratedText$1(textNode, text) {
    return textNode.nodeValue !== text;
  }
  function shouldAutoFocusHostComponent(type, props) {
    switch (type) {
      case "button":
      case "input":
      case "select":
      case "textarea":
        return !!props.autoFocus;
    }
    return !1;
  }
  function shouldSetTextContent(type, props) {
    return (
      "textarea" === type ||
      "string" === typeof props.children ||
      "number" === typeof props.children ||
      ("object" === typeof props.dangerouslySetInnerHTML &&
        null !== props.dangerouslySetInnerHTML &&
        "string" === typeof props.dangerouslySetInnerHTML.__html)
    );
  }
  function getNextHydratableSibling(instance) {
    for (
      instance = instance.nextSibling;
      instance && 1 !== instance.nodeType && 3 !== instance.nodeType;

    )
      instance = instance.nextSibling;
    return instance;
  }
  function getFirstHydratableChild(parentInstance) {
    for (
      parentInstance = parentInstance.firstChild;
      parentInstance &&
      1 !== parentInstance.nodeType &&
      3 !== parentInstance.nodeType;

    )
      parentInstance = parentInstance.nextSibling;
    return parentInstance;
  }
  function pop(cursor, fiber) {
    0 > index ||
      ((cursor.current = valueStack[index]),
      (valueStack[index] = null),
      index--);
  }
  function push(cursor, value, fiber) {
    index++;
    valueStack[index] = cursor.current;
    cursor.current = value;
  }
  function getUnmaskedContext(workInProgress) {
    return isContextProvider(workInProgress)
      ? previousContext
      : contextStackCursor.current;
  }
  function getMaskedContext(workInProgress, unmaskedContext) {
    var contextTypes = workInProgress.type.contextTypes;
    if (!contextTypes) return emptyContextObject;
    var instance = workInProgress.stateNode;
    if (
      instance &&
      instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext
    )
      return instance.__reactInternalMemoizedMaskedChildContext;
    var context = {},
      key;
    for (key in contextTypes) context[key] = unmaskedContext[key];
    instance &&
      ((workInProgress = workInProgress.stateNode),
      (workInProgress.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext),
      (workInProgress.__reactInternalMemoizedMaskedChildContext = context));
    return context;
  }
  function isContextProvider(fiber) {
    return 2 === fiber.tag && null != fiber.type.childContextTypes;
  }
  function popContextProvider(fiber) {
    isContextProvider(fiber) &&
      (pop(didPerformWorkStackCursor, fiber), pop(contextStackCursor, fiber));
  }
  function popTopLevelContextObject(fiber) {
    pop(didPerformWorkStackCursor, fiber);
    pop(contextStackCursor, fiber);
  }
  function pushTopLevelContextObject(fiber, context, didChange) {
    contextStackCursor.current !== emptyContextObject
      ? reactProdInvariant("168")
      : void 0;
    push(contextStackCursor, context, fiber);
    push(didPerformWorkStackCursor, didChange, fiber);
  }
  function processChildContext(fiber, parentContext) {
    var instance = fiber.stateNode;
    fiber = fiber.type;
    var childContextTypes = fiber.childContextTypes;
    if ("function" !== typeof instance.getChildContext) return parentContext;
    instance = instance.getChildContext();
    for (var contextKey in instance)
      contextKey in childContextTypes
        ? void 0
        : reactProdInvariant(
            "108",
            getComponentName(fiber) || "Unknown",
            contextKey
          );
    return _assign({}, parentContext, instance);
  }
  function pushContextProvider(workInProgress) {
    if (!isContextProvider(workInProgress)) return !1;
    var instance = workInProgress.stateNode;
    instance =
      (instance && instance.__reactInternalMemoizedMergedChildContext) ||
      emptyContextObject;
    previousContext = contextStackCursor.current;
    push(contextStackCursor, instance, workInProgress);
    push(
      didPerformWorkStackCursor,
      didPerformWorkStackCursor.current,
      workInProgress
    );
    return !0;
  }
  function invalidateContextProvider(workInProgress, didChange) {
    var instance = workInProgress.stateNode;
    instance ? void 0 : reactProdInvariant("169");
    if (didChange) {
      var mergedContext = processChildContext(workInProgress, previousContext);
      instance.__reactInternalMemoizedMergedChildContext = mergedContext;
      pop(didPerformWorkStackCursor, workInProgress);
      pop(contextStackCursor, workInProgress);
      push(contextStackCursor, mergedContext, workInProgress);
    } else pop(didPerformWorkStackCursor, workInProgress);
    push(didPerformWorkStackCursor, didChange, workInProgress);
  }
  function catchErrors(fn) {
    return function(arg) {
      try {
        return fn(arg);
      } catch (err) {}
    };
  }
  function injectInternals(internals) {
    if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
    var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (hook.isDisabled || !hook.supportsFiber) return !0;
    try {
      var rendererID = hook.inject(internals);
      onCommitFiberRoot = catchErrors(function(root) {
        return hook.onCommitFiberRoot(rendererID, root);
      });
      onCommitFiberUnmount = catchErrors(function(fiber) {
        return hook.onCommitFiberUnmount(rendererID, fiber);
      });
    } catch (err) {}
    return !0;
  }
  function FiberNode(tag, pendingProps, key, mode) {
    this.tag = tag;
    this.key = key;
    this.sibling = this.child = this.return = this.stateNode = this.type = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = pendingProps;
    this.firstContextDependency = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = mode;
    this.effectTag = 0;
    this.lastEffect = this.firstEffect = this.nextEffect = null;
    this.childExpirationTime = this.expirationTime = 0;
    this.alternate = null;
  }
  function createWorkInProgress(current, pendingProps, expirationTime) {
    var workInProgress = current.alternate;
    null === workInProgress
      ? ((workInProgress = new FiberNode(
          current.tag,
          pendingProps,
          current.key,
          current.mode
        )),
        (workInProgress.type = current.type),
        (workInProgress.stateNode = current.stateNode),
        (workInProgress.alternate = current),
        (current.alternate = workInProgress))
      : ((workInProgress.pendingProps = pendingProps),
        (workInProgress.effectTag = 0),
        (workInProgress.nextEffect = null),
        (workInProgress.firstEffect = null),
        (workInProgress.lastEffect = null));
    workInProgress.childExpirationTime = current.childExpirationTime;
    workInProgress.expirationTime =
      pendingProps !== current.pendingProps
        ? expirationTime
        : current.expirationTime;
    workInProgress.child = current.child;
    workInProgress.memoizedProps = current.memoizedProps;
    workInProgress.memoizedState = current.memoizedState;
    workInProgress.updateQueue = current.updateQueue;
    workInProgress.firstContextDependency = current.firstContextDependency;
    workInProgress.sibling = current.sibling;
    workInProgress.index = current.index;
    workInProgress.ref = current.ref;
    return workInProgress;
  }
  function createFiberFromElement(element, mode, expirationTime) {
    var type = element.type,
      key = element.key;
    element = element.props;
    if ("function" === typeof type)
      var fiberTag = type.prototype && type.prototype.isReactComponent ? 2 : 0;
    else if ("string" === typeof type) fiberTag = 5;
    else
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return createFiberFromFragment(
            element.children,
            mode,
            expirationTime,
            key
          );
        case REACT_ASYNC_MODE_TYPE:
          fiberTag = 11;
          mode |= 3;
          break;
        case REACT_STRICT_MODE_TYPE:
          fiberTag = 11;
          mode |= 2;
          break;
        case REACT_PROFILER_TYPE:
          return (
            (type = new FiberNode(15, element, key, mode | 4)),
            (type.type = REACT_PROFILER_TYPE),
            (type.expirationTime = expirationTime),
            type
          );
        case REACT_PLACEHOLDER_TYPE:
          fiberTag = 16;
          break;
        default:
          a: {
            switch (
              "object" === typeof type && null !== type ? type.$$typeof : null
            ) {
              case REACT_PROVIDER_TYPE:
                fiberTag = 13;
                break a;
              case REACT_CONTEXT_TYPE:
                fiberTag = 12;
                break a;
              case REACT_FORWARD_REF_TYPE:
                fiberTag = 14;
                break a;
              default:
                reactProdInvariant(
                  "130",
                  null == type ? type : typeof type,
                  ""
                );
            }
            fiberTag = void 0;
          }
      }
    mode = new FiberNode(fiberTag, element, key, mode);
    mode.type = type;
    mode.expirationTime = expirationTime;
    return mode;
  }
  function createFiberFromFragment(elements, mode, expirationTime, key) {
    elements = new FiberNode(10, elements, key, mode);
    elements.expirationTime = expirationTime;
    return elements;
  }
  function createFiberFromText(content, mode, expirationTime) {
    content = new FiberNode(6, content, null, mode);
    content.expirationTime = expirationTime;
    return content;
  }
  function createFiberFromPortal(portal, mode, expirationTime) {
    mode = new FiberNode(
      4,
      null !== portal.children ? portal.children : [],
      portal.key,
      mode
    );
    mode.expirationTime = expirationTime;
    mode.stateNode = {
      containerInfo: portal.containerInfo,
      pendingChildren: null,
      implementation: portal.implementation
    };
    return mode;
  }
  function createFiberRoot(containerInfo, isAsync, hydrate) {
    isAsync = new FiberNode(3, null, null, isAsync ? 3 : 0);
    containerInfo = {
      current: isAsync,
      containerInfo: containerInfo,
      pendingChildren: null,
      earliestPendingTime: 0,
      latestPendingTime: 0,
      earliestSuspendedTime: 0,
      latestSuspendedTime: 0,
      latestPingedTime: 0,
      didError: !1,
      pendingCommitExpirationTime: 0,
      finishedWork: null,
      timeoutHandle: -1,
      context: null,
      pendingContext: null,
      hydrate: hydrate,
      nextExpirationTimeToWorkOn: 0,
      expirationTime: 0,
      firstBatch: null,
      nextScheduledRoot: null
    };
    return (isAsync.stateNode = containerInfo);
  }
  function markPendingPriorityLevel(root, expirationTime) {
    root.didError = !1;
    var earliestPendingTime = root.earliestPendingTime;
    0 === earliestPendingTime
      ? (root.earliestPendingTime = root.latestPendingTime = expirationTime)
      : earliestPendingTime > expirationTime
        ? (root.earliestPendingTime = expirationTime)
        : root.latestPendingTime < expirationTime &&
          (root.latestPendingTime = expirationTime);
    findNextExpirationTimeToWorkOn(expirationTime, root);
  }
  function findNextExpirationTimeToWorkOn(completedExpirationTime, root) {
    var earliestSuspendedTime = root.earliestSuspendedTime,
      latestSuspendedTime = root.latestSuspendedTime,
      earliestPendingTime = root.earliestPendingTime,
      latestPingedTime = root.latestPingedTime;
    earliestPendingTime =
      0 !== earliestPendingTime ? earliestPendingTime : latestPingedTime;
    0 === earliestPendingTime &&
      (0 === completedExpirationTime ||
        latestSuspendedTime > completedExpirationTime) &&
      (earliestPendingTime = latestSuspendedTime);
    completedExpirationTime = earliestPendingTime;
    0 !== completedExpirationTime &&
      0 !== earliestSuspendedTime &&
      earliestSuspendedTime < completedExpirationTime &&
      (completedExpirationTime = earliestSuspendedTime);
    root.nextExpirationTimeToWorkOn = earliestPendingTime;
    root.expirationTime = completedExpirationTime;
  }
  function createUpdateQueue(baseState) {
    return {
      baseState: baseState,
      firstUpdate: null,
      lastUpdate: null,
      firstCapturedUpdate: null,
      lastCapturedUpdate: null,
      firstEffect: null,
      lastEffect: null,
      firstCapturedEffect: null,
      lastCapturedEffect: null
    };
  }
  function cloneUpdateQueue(currentQueue) {
    return {
      baseState: currentQueue.baseState,
      firstUpdate: currentQueue.firstUpdate,
      lastUpdate: currentQueue.lastUpdate,
      firstCapturedUpdate: null,
      lastCapturedUpdate: null,
      firstEffect: null,
      lastEffect: null,
      firstCapturedEffect: null,
      lastCapturedEffect: null
    };
  }
  function createUpdate(expirationTime) {
    return {
      expirationTime: expirationTime,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
      nextEffect: null
    };
  }
  function appendUpdateToQueue(queue, update) {
    null === queue.lastUpdate
      ? (queue.firstUpdate = queue.lastUpdate = update)
      : ((queue.lastUpdate.next = update), (queue.lastUpdate = update));
  }
  function enqueueUpdate(fiber, update) {
    var alternate = fiber.alternate;
    if (null === alternate) {
      var queue1 = fiber.updateQueue;
      var queue2 = null;
      null === queue1 &&
        (queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState));
    } else (queue1 = fiber.updateQueue), (queue2 = alternate.updateQueue), null === queue1 ? (null === queue2 ? ((queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState)), (queue2 = alternate.updateQueue = createUpdateQueue(alternate.memoizedState))) : (queue1 = fiber.updateQueue = cloneUpdateQueue(queue2))) : null === queue2 && (queue2 = alternate.updateQueue = cloneUpdateQueue(queue1));
    null === queue2 || queue1 === queue2
      ? appendUpdateToQueue(queue1, update)
      : null === queue1.lastUpdate || null === queue2.lastUpdate
        ? (appendUpdateToQueue(queue1, update),
          appendUpdateToQueue(queue2, update))
        : (appendUpdateToQueue(queue1, update), (queue2.lastUpdate = update));
  }
  function enqueueCapturedUpdate(workInProgress, update) {
    var workInProgressQueue = workInProgress.updateQueue;
    workInProgressQueue =
      null === workInProgressQueue
        ? (workInProgress.updateQueue = createUpdateQueue(
            workInProgress.memoizedState
          ))
        : ensureWorkInProgressQueueIsAClone(
            workInProgress,
            workInProgressQueue
          );
    null === workInProgressQueue.lastCapturedUpdate
      ? (workInProgressQueue.firstCapturedUpdate = workInProgressQueue.lastCapturedUpdate = update)
      : ((workInProgressQueue.lastCapturedUpdate.next = update),
        (workInProgressQueue.lastCapturedUpdate = update));
  }
  function ensureWorkInProgressQueueIsAClone(workInProgress, queue) {
    var current = workInProgress.alternate;
    null !== current &&
      queue === current.updateQueue &&
      (queue = workInProgress.updateQueue = cloneUpdateQueue(queue));
    return queue;
  }
  function getStateFromUpdate(
    workInProgress,
    queue,
    update,
    prevState,
    nextProps,
    instance
  ) {
    switch (update.tag) {
      case 1:
        return (
          (workInProgress = update.payload),
          "function" === typeof workInProgress
            ? workInProgress.call(instance, prevState, nextProps)
            : workInProgress
        );
      case 3:
        workInProgress.effectTag = (workInProgress.effectTag & -1025) | 64;
      case 0:
        workInProgress = update.payload;
        nextProps =
          "function" === typeof workInProgress
            ? workInProgress.call(instance, prevState, nextProps)
            : workInProgress;
        if (null === nextProps || void 0 === nextProps) break;
        return _assign({}, prevState, nextProps);
      case 2:
        hasForceUpdate = !0;
    }
    return prevState;
  }
  function processUpdateQueue(
    workInProgress,
    queue,
    props,
    instance,
    renderExpirationTime
  ) {
    hasForceUpdate = !1;
    queue = ensureWorkInProgressQueueIsAClone(workInProgress, queue);
    for (
      var newBaseState = queue.baseState,
        newFirstUpdate = null,
        newExpirationTime = 0,
        update = queue.firstUpdate,
        resultState = newBaseState;
      null !== update;

    ) {
      var updateExpirationTime = update.expirationTime;
      if (updateExpirationTime > renderExpirationTime) {
        if (
          (null === newFirstUpdate &&
            ((newFirstUpdate = update), (newBaseState = resultState)),
          0 === newExpirationTime || newExpirationTime > updateExpirationTime)
        )
          newExpirationTime = updateExpirationTime;
      } else
        (resultState = getStateFromUpdate(
          workInProgress,
          queue,
          update,
          resultState,
          props,
          instance
        )),
          null !== update.callback &&
            ((workInProgress.effectTag |= 32),
            (update.nextEffect = null),
            null === queue.lastEffect
              ? (queue.firstEffect = queue.lastEffect = update)
              : ((queue.lastEffect.nextEffect = update),
                (queue.lastEffect = update)));
      update = update.next;
    }
    updateExpirationTime = null;
    for (update = queue.firstCapturedUpdate; null !== update; ) {
      var _updateExpirationTime = update.expirationTime;
      if (_updateExpirationTime > renderExpirationTime) {
        if (
          (null === updateExpirationTime &&
            ((updateExpirationTime = update),
            null === newFirstUpdate && (newBaseState = resultState)),
          0 === newExpirationTime || newExpirationTime > _updateExpirationTime)
        )
          newExpirationTime = _updateExpirationTime;
      } else
        (resultState = getStateFromUpdate(
          workInProgress,
          queue,
          update,
          resultState,
          props,
          instance
        )),
          null !== update.callback &&
            ((workInProgress.effectTag |= 32),
            (update.nextEffect = null),
            null === queue.lastCapturedEffect
              ? (queue.firstCapturedEffect = queue.lastCapturedEffect = update)
              : ((queue.lastCapturedEffect.nextEffect = update),
                (queue.lastCapturedEffect = update)));
      update = update.next;
    }
    null === newFirstUpdate && (queue.lastUpdate = null);
    null === updateExpirationTime
      ? (queue.lastCapturedUpdate = null)
      : (workInProgress.effectTag |= 32);
    null === newFirstUpdate &&
      null === updateExpirationTime &&
      (newBaseState = resultState);
    queue.baseState = newBaseState;
    queue.firstUpdate = newFirstUpdate;
    queue.firstCapturedUpdate = updateExpirationTime;
    workInProgress.expirationTime = newExpirationTime;
    workInProgress.memoizedState = resultState;
  }
  function callCallback(callback, context) {
    "function" !== typeof callback
      ? reactProdInvariant("191", callback)
      : void 0;
    callback.call(context);
  }
  function commitUpdateQueue(
    finishedWork,
    finishedQueue,
    instance,
    renderExpirationTime
  ) {
    null !== finishedQueue.firstCapturedUpdate &&
      (null !== finishedQueue.lastUpdate &&
        ((finishedQueue.lastUpdate.next = finishedQueue.firstCapturedUpdate),
        (finishedQueue.lastUpdate = finishedQueue.lastCapturedUpdate)),
      (finishedQueue.firstCapturedUpdate = finishedQueue.lastCapturedUpdate = null));
    finishedWork = finishedQueue.firstEffect;
    for (
      finishedQueue.firstEffect = finishedQueue.lastEffect = null;
      null !== finishedWork;

    )
      (renderExpirationTime = finishedWork.callback),
        null !== renderExpirationTime &&
          ((finishedWork.callback = null),
          callCallback(renderExpirationTime, instance)),
        (finishedWork = finishedWork.nextEffect);
    finishedWork = finishedQueue.firstCapturedEffect;
    for (
      finishedQueue.firstCapturedEffect = finishedQueue.lastCapturedEffect = null;
      null !== finishedWork;

    )
      (finishedQueue = finishedWork.callback),
        null !== finishedQueue &&
          ((finishedWork.callback = null),
          callCallback(finishedQueue, instance)),
        (finishedWork = finishedWork.nextEffect);
  }
  function createCapturedValue(value, source) {
    return {
      value: value,
      source: source,
      stack: getStackByFiberInDevAndProd(source)
    };
  }
  function pushProvider(providerFiber) {
    var context = providerFiber.type._context;
    push(changedBitsCursor, context._changedBits, providerFiber);
    push(valueCursor, context._currentValue, providerFiber);
    context._currentValue = providerFiber.pendingProps.value;
    context._changedBits = providerFiber.stateNode;
  }
  function popProvider(providerFiber) {
    var changedBits = changedBitsCursor.current,
      currentValue = valueCursor.current;
    pop(valueCursor, providerFiber);
    pop(changedBitsCursor, providerFiber);
    providerFiber = providerFiber.type._context;
    providerFiber._currentValue = currentValue;
    providerFiber._changedBits = changedBits;
  }
  function propagateContextChange(
    workInProgress,
    context,
    changedBits,
    renderExpirationTime
  ) {
    var fiber = workInProgress.child;
    null !== fiber && (fiber.return = workInProgress);
    for (; null !== fiber; ) {
      var dependency = fiber.firstContextDependency;
      if (null !== dependency) {
        do {
          if (
            dependency.context === context &&
            0 !== (dependency.observedBits & changedBits)
          ) {
            if (
              0 === fiber.expirationTime ||
              fiber.expirationTime > renderExpirationTime
            )
              fiber.expirationTime = renderExpirationTime;
            var nextFiber = fiber.alternate;
            null !== nextFiber &&
              (0 === nextFiber.expirationTime ||
                nextFiber.expirationTime > renderExpirationTime) &&
              (nextFiber.expirationTime = renderExpirationTime);
            for (var node = fiber.return; null !== node; ) {
              nextFiber = node.alternate;
              if (
                0 === node.childExpirationTime ||
                node.childExpirationTime > renderExpirationTime
              )
                (node.childExpirationTime = renderExpirationTime),
                  null !== nextFiber &&
                    (0 === nextFiber.childExpirationTime ||
                      nextFiber.childExpirationTime > renderExpirationTime) &&
                    (nextFiber.childExpirationTime = renderExpirationTime);
              else if (
                null !== nextFiber &&
                (0 === nextFiber.childExpirationTime ||
                  nextFiber.childExpirationTime > renderExpirationTime)
              )
                nextFiber.childExpirationTime = renderExpirationTime;
              else break;
              node = node.return;
            }
            nextFiber = null;
          } else nextFiber = fiber.child;
          dependency = dependency.next;
        } while (null !== dependency);
      } else
        nextFiber =
          13 === fiber.tag
            ? fiber.type === workInProgress.type
              ? null
              : fiber.child
            : fiber.child;
      if (null !== nextFiber) nextFiber.return = fiber;
      else
        for (nextFiber = fiber; null !== nextFiber; ) {
          if (nextFiber === workInProgress) {
            nextFiber = null;
            break;
          }
          fiber = nextFiber.sibling;
          if (null !== fiber) {
            fiber.return = nextFiber.return;
            nextFiber = fiber;
            break;
          }
          nextFiber = nextFiber.return;
        }
      fiber = nextFiber;
    }
  }
  function prepareToReadContext(workInProgress, renderExpirationTime) {
    currentlyRenderingFiber = workInProgress;
    lastContext = lastContextDependency = null;
    var firstContextDependency = workInProgress.firstContextDependency;
    if (null !== firstContextDependency) {
      workInProgress.firstContextDependency = null;
      var hasPendingContext = !1;
      do {
        var _context = firstContextDependency.context,
          changedBits = _context._changedBits;
        0 !== changedBits &&
          (propagateContextChange(
            workInProgress,
            _context,
            changedBits,
            renderExpirationTime
          ),
          0 !== (changedBits & firstContextDependency.observedBits) &&
            (hasPendingContext = !0));
        firstContextDependency = firstContextDependency.next;
      } while (null !== firstContextDependency);
      return hasPendingContext;
    }
    return !1;
  }
  function readContext(context, observedBits) {
    "number" !== typeof observedBits &&
      (observedBits = !1 === observedBits ? 0 : 1073741823);
    if (null === lastContext)
      null === currentlyRenderingFiber
        ? invariant(
            !1,
            "Context.unstable_read(): Context can only be read while React is rendering, e.g. inside the render method or getDerivedStateFromProps."
          )
        : void 0,
        (currentlyRenderingFiber.firstContextDependency = lastContextDependency = {
          context: context,
          observedBits: observedBits,
          next: null
        }),
        (lastContext = context);
    else {
      var lastDependency = lastContextDependency;
      lastContext === context
        ? (lastDependency.observedBits |= observedBits)
        : ((lastContextDependency = lastDependency.next = {
            context: context,
            observedBits: observedBits,
            next: null
          }),
          (lastContext = context));
    }
    return context._currentValue;
  }
  function requiredContext(c) {
    c === NO_CONTEXT ? reactProdInvariant("174") : void 0;
    return c;
  }
  function pushHostContainer(fiber, nextRootInstance) {
    push(rootInstanceStackCursor, nextRootInstance, fiber);
    push(contextFiberStackCursor, fiber, fiber);
    push(contextStackCursor$1, NO_CONTEXT, fiber);
    var type = nextRootInstance.nodeType;
    switch (type) {
      case 9:
      case 11:
        nextRootInstance = (nextRootInstance = nextRootInstance.documentElement)
          ? nextRootInstance.namespaceURI
          : getChildNamespace(null, "");
        break;
      default:
        (type = 8 === type ? nextRootInstance.parentNode : nextRootInstance),
          (nextRootInstance = type.namespaceURI || null),
          (type = type.tagName),
          (nextRootInstance = getChildNamespace(nextRootInstance, type));
    }
    pop(contextStackCursor$1, fiber);
    push(contextStackCursor$1, nextRootInstance, fiber);
  }
  function popHostContainer(fiber) {
    pop(contextStackCursor$1, fiber);
    pop(contextFiberStackCursor, fiber);
    pop(rootInstanceStackCursor, fiber);
  }
  function pushHostContext(fiber) {
    requiredContext(rootInstanceStackCursor.current);
    var context = requiredContext(contextStackCursor$1.current);
    var nextContext = getChildNamespace(context, fiber.type);
    context !== nextContext &&
      (push(contextFiberStackCursor, fiber, fiber),
      push(contextStackCursor$1, nextContext, fiber));
  }
  function popHostContext(fiber) {
    contextFiberStackCursor.current === fiber &&
      (pop(contextStackCursor$1, fiber), pop(contextFiberStackCursor, fiber));
  }
  function applyDerivedStateFromProps(
    workInProgress,
    getDerivedStateFromProps,
    nextProps
  ) {
    var prevState = workInProgress.memoizedState;
    getDerivedStateFromProps = getDerivedStateFromProps(nextProps, prevState);
    prevState =
      null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps
        ? prevState
        : _assign({}, prevState, getDerivedStateFromProps);
    workInProgress.memoizedState = prevState;
    getDerivedStateFromProps = workInProgress.updateQueue;
    null !== getDerivedStateFromProps &&
      0 === workInProgress.expirationTime &&
      (getDerivedStateFromProps.baseState = prevState);
  }
  function checkShouldComponentUpdate(
    workInProgress,
    oldProps,
    newProps,
    oldState,
    newState,
    nextLegacyContext
  ) {
    var instance = workInProgress.stateNode;
    workInProgress = workInProgress.type;
    return "function" === typeof instance.shouldComponentUpdate
      ? instance.shouldComponentUpdate(newProps, newState, nextLegacyContext)
      : workInProgress.prototype &&
        workInProgress.prototype.isPureReactComponent
        ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
        : !0;
  }
  function callComponentWillReceiveProps(
    workInProgress,
    instance,
    newProps,
    nextLegacyContext
  ) {
    workInProgress = instance.state;
    "function" === typeof instance.componentWillReceiveProps &&
      instance.componentWillReceiveProps(newProps, nextLegacyContext);
    "function" === typeof instance.UNSAFE_componentWillReceiveProps &&
      instance.UNSAFE_componentWillReceiveProps(newProps, nextLegacyContext);
    instance.state !== workInProgress &&
      classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
  }
  function mountClassInstance(workInProgress, renderExpirationTime) {
    var ctor = workInProgress.type,
      instance = workInProgress.stateNode,
      props = workInProgress.pendingProps,
      unmaskedContext = getUnmaskedContext(workInProgress);
    instance.props = props;
    instance.state = workInProgress.memoizedState;
    instance.refs = emptyRefsObject;
    instance.context = getMaskedContext(workInProgress, unmaskedContext);
    unmaskedContext = workInProgress.updateQueue;
    null !== unmaskedContext &&
      (processUpdateQueue(
        workInProgress,
        unmaskedContext,
        props,
        instance,
        renderExpirationTime
      ),
      (instance.state = workInProgress.memoizedState));
    unmaskedContext = ctor.getDerivedStateFromProps;
    "function" === typeof unmaskedContext &&
      (applyDerivedStateFromProps(workInProgress, unmaskedContext, props),
      (instance.state = workInProgress.memoizedState));
    "function" === typeof ctor.getDerivedStateFromProps ||
      "function" === typeof instance.getSnapshotBeforeUpdate ||
      ("function" !== typeof instance.UNSAFE_componentWillMount &&
        "function" !== typeof instance.componentWillMount) ||
      ((ctor = instance.state),
      "function" === typeof instance.componentWillMount &&
        instance.componentWillMount(),
      "function" === typeof instance.UNSAFE_componentWillMount &&
        instance.UNSAFE_componentWillMount(),
      ctor !== instance.state &&
        classComponentUpdater.enqueueReplaceState(
          instance,
          instance.state,
          null
        ),
      (unmaskedContext = workInProgress.updateQueue),
      null !== unmaskedContext &&
        (processUpdateQueue(
          workInProgress,
          unmaskedContext,
          props,
          instance,
          renderExpirationTime
        ),
        (instance.state = workInProgress.memoizedState)));
    "function" === typeof instance.componentDidMount &&
      (workInProgress.effectTag |= 4);
  }
  function coerceRef(returnFiber, current$$1, element) {
    returnFiber = element.ref;
    if (
      null !== returnFiber &&
      "function" !== typeof returnFiber &&
      "object" !== typeof returnFiber
    ) {
      if (element._owner) {
        element = element._owner;
        var inst = void 0;
        element &&
          (2 !== element.tag ? reactProdInvariant("110") : void 0,
          (inst = element.stateNode));
        inst ? void 0 : reactProdInvariant("147", returnFiber);
        var stringRef = "" + returnFiber;
        if (
          null !== current$$1 &&
          null !== current$$1.ref &&
          "function" === typeof current$$1.ref &&
          current$$1.ref._stringRef === stringRef
        )
          return current$$1.ref;
        current$$1 = function(value) {
          var refs = inst.refs;
          refs === emptyRefsObject && (refs = inst.refs = {});
          null === value ? delete refs[stringRef] : (refs[stringRef] = value);
        };
        current$$1._stringRef = stringRef;
        return current$$1;
      }
      "string" !== typeof returnFiber ? reactProdInvariant("148") : void 0;
      element._owner ? void 0 : reactProdInvariant("254", returnFiber);
    }
    return returnFiber;
  }
  function throwOnInvalidObjectType(returnFiber, newChild) {
    "textarea" !== returnFiber.type &&
      reactProdInvariant(
        "31",
        "[object Object]" === Object.prototype.toString.call(newChild)
          ? "object with keys {" + Object.keys(newChild).join(", ") + "}"
          : newChild,
        ""
      );
  }
  function ChildReconciler(shouldTrackSideEffects) {
    function deleteChild(returnFiber, childToDelete) {
      if (shouldTrackSideEffects) {
        var last = returnFiber.lastEffect;
        null !== last
          ? ((last.nextEffect = childToDelete),
            (returnFiber.lastEffect = childToDelete))
          : (returnFiber.firstEffect = returnFiber.lastEffect = childToDelete);
        childToDelete.nextEffect = null;
        childToDelete.effectTag = 8;
      }
    }
    function deleteRemainingChildren(returnFiber, currentFirstChild) {
      if (!shouldTrackSideEffects) return null;
      for (; null !== currentFirstChild; )
        deleteChild(returnFiber, currentFirstChild),
          (currentFirstChild = currentFirstChild.sibling);
      return null;
    }
    function mapRemainingChildren(returnFiber, currentFirstChild) {
      for (returnFiber = new Map(); null !== currentFirstChild; )
        null !== currentFirstChild.key
          ? returnFiber.set(currentFirstChild.key, currentFirstChild)
          : returnFiber.set(currentFirstChild.index, currentFirstChild),
          (currentFirstChild = currentFirstChild.sibling);
      return returnFiber;
    }
    function useFiber(fiber, pendingProps, expirationTime) {
      fiber = createWorkInProgress(fiber, pendingProps, expirationTime);
      fiber.index = 0;
      fiber.sibling = null;
      return fiber;
    }
    function placeChild(newFiber, lastPlacedIndex, newIndex) {
      newFiber.index = newIndex;
      if (!shouldTrackSideEffects) return lastPlacedIndex;
      newIndex = newFiber.alternate;
      if (null !== newIndex)
        return (
          (newIndex = newIndex.index),
          newIndex < lastPlacedIndex
            ? ((newFiber.effectTag = 2), lastPlacedIndex)
            : newIndex
        );
      newFiber.effectTag = 2;
      return lastPlacedIndex;
    }
    function placeSingleChild(newFiber) {
      shouldTrackSideEffects &&
        null === newFiber.alternate &&
        (newFiber.effectTag = 2);
      return newFiber;
    }
    function updateTextNode(
      returnFiber,
      current$$1,
      textContent,
      expirationTime
    ) {
      if (null === current$$1 || 6 !== current$$1.tag)
        return (
          (current$$1 = createFiberFromText(
            textContent,
            returnFiber.mode,
            expirationTime
          )),
          (current$$1.return = returnFiber),
          current$$1
        );
      current$$1 = useFiber(current$$1, textContent, expirationTime);
      current$$1.return = returnFiber;
      return current$$1;
    }
    function updateElement(returnFiber, current$$1, element, expirationTime) {
      if (null !== current$$1 && current$$1.type === element.type)
        return (
          (expirationTime = useFiber(
            current$$1,
            element.props,
            expirationTime
          )),
          (expirationTime.ref = coerceRef(returnFiber, current$$1, element)),
          (expirationTime.return = returnFiber),
          expirationTime
        );
      expirationTime = createFiberFromElement(
        element,
        returnFiber.mode,
        expirationTime
      );
      expirationTime.ref = coerceRef(returnFiber, current$$1, element);
      expirationTime.return = returnFiber;
      return expirationTime;
    }
    function updatePortal(returnFiber, current$$1, portal, expirationTime) {
      if (
        null === current$$1 ||
        4 !== current$$1.tag ||
        current$$1.stateNode.containerInfo !== portal.containerInfo ||
        current$$1.stateNode.implementation !== portal.implementation
      )
        return (
          (current$$1 = createFiberFromPortal(
            portal,
            returnFiber.mode,
            expirationTime
          )),
          (current$$1.return = returnFiber),
          current$$1
        );
      current$$1 = useFiber(current$$1, portal.children || [], expirationTime);
      current$$1.return = returnFiber;
      return current$$1;
    }
    function updateFragment(
      returnFiber,
      current$$1,
      fragment,
      expirationTime,
      key
    ) {
      if (null === current$$1 || 10 !== current$$1.tag)
        return (
          (current$$1 = createFiberFromFragment(
            fragment,
            returnFiber.mode,
            expirationTime,
            key
          )),
          (current$$1.return = returnFiber),
          current$$1
        );
      current$$1 = useFiber(current$$1, fragment, expirationTime);
      current$$1.return = returnFiber;
      return current$$1;
    }
    function createChild(returnFiber, newChild, expirationTime) {
      if ("string" === typeof newChild || "number" === typeof newChild)
        return (
          (newChild = createFiberFromText(
            "" + newChild,
            returnFiber.mode,
            expirationTime
          )),
          (newChild.return = returnFiber),
          newChild
        );
      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return (
              (expirationTime = createFiberFromElement(
                newChild,
                returnFiber.mode,
                expirationTime
              )),
              (expirationTime.ref = coerceRef(returnFiber, null, newChild)),
              (expirationTime.return = returnFiber),
              expirationTime
            );
          case REACT_PORTAL_TYPE:
            return (
              (newChild = createFiberFromPortal(
                newChild,
                returnFiber.mode,
                expirationTime
              )),
              (newChild.return = returnFiber),
              newChild
            );
        }
        if (isArray$1(newChild) || getIteratorFn(newChild))
          return (
            (newChild = createFiberFromFragment(
              newChild,
              returnFiber.mode,
              expirationTime,
              null
            )),
            (newChild.return = returnFiber),
            newChild
          );
        throwOnInvalidObjectType(returnFiber, newChild);
      }
      return null;
    }
    function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
      var key = null !== oldFiber ? oldFiber.key : null;
      if ("string" === typeof newChild || "number" === typeof newChild)
        return null !== key
          ? null
          : updateTextNode(
              returnFiber,
              oldFiber,
              "" + newChild,
              expirationTime
            );
      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return newChild.key === key
              ? newChild.type === REACT_FRAGMENT_TYPE
                ? updateFragment(
                    returnFiber,
                    oldFiber,
                    newChild.props.children,
                    expirationTime,
                    key
                  )
                : updateElement(returnFiber, oldFiber, newChild, expirationTime)
              : null;
          case REACT_PORTAL_TYPE:
            return newChild.key === key
              ? updatePortal(returnFiber, oldFiber, newChild, expirationTime)
              : null;
        }
        if (isArray$1(newChild) || getIteratorFn(newChild))
          return null !== key
            ? null
            : updateFragment(
                returnFiber,
                oldFiber,
                newChild,
                expirationTime,
                null
              );
        throwOnInvalidObjectType(returnFiber, newChild);
      }
      return null;
    }
    function updateFromMap(
      existingChildren,
      returnFiber,
      newIdx,
      newChild,
      expirationTime
    ) {
      if ("string" === typeof newChild || "number" === typeof newChild)
        return (
          (existingChildren = existingChildren.get(newIdx) || null),
          updateTextNode(
            returnFiber,
            existingChildren,
            "" + newChild,
            expirationTime
          )
        );
      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return (
              (existingChildren =
                existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null),
              newChild.type === REACT_FRAGMENT_TYPE
                ? updateFragment(
                    returnFiber,
                    existingChildren,
                    newChild.props.children,
                    expirationTime,
                    newChild.key
                  )
                : updateElement(
                    returnFiber,
                    existingChildren,
                    newChild,
                    expirationTime
                  )
            );
          case REACT_PORTAL_TYPE:
            return (
              (existingChildren =
                existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null),
              updatePortal(
                returnFiber,
                existingChildren,
                newChild,
                expirationTime
              )
            );
        }
        if (isArray$1(newChild) || getIteratorFn(newChild))
          return (
            (existingChildren = existingChildren.get(newIdx) || null),
            updateFragment(
              returnFiber,
              existingChildren,
              newChild,
              expirationTime,
              null
            )
          );
        throwOnInvalidObjectType(returnFiber, newChild);
      }
      return null;
    }
    function reconcileChildrenArray(
      returnFiber,
      currentFirstChild,
      newChildren,
      expirationTime
    ) {
      for (
        var resultingFirstChild = null,
          previousNewFiber = null,
          oldFiber = currentFirstChild,
          newIdx = (currentFirstChild = 0),
          nextOldFiber = null;
        null !== oldFiber && newIdx < newChildren.length;
        newIdx++
      ) {
        oldFiber.index > newIdx
          ? ((nextOldFiber = oldFiber), (oldFiber = null))
          : (nextOldFiber = oldFiber.sibling);
        var newFiber = updateSlot(
          returnFiber,
          oldFiber,
          newChildren[newIdx],
          expirationTime
        );
        if (null === newFiber) {
          null === oldFiber && (oldFiber = nextOldFiber);
          break;
        }
        shouldTrackSideEffects &&
          oldFiber &&
          null === newFiber.alternate &&
          deleteChild(returnFiber, oldFiber);
        currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
        null === previousNewFiber
          ? (resultingFirstChild = newFiber)
          : (previousNewFiber.sibling = newFiber);
        previousNewFiber = newFiber;
        oldFiber = nextOldFiber;
      }
      if (newIdx === newChildren.length)
        return (
          deleteRemainingChildren(returnFiber, oldFiber), resultingFirstChild
        );
      if (null === oldFiber) {
        for (; newIdx < newChildren.length; newIdx++)
          if (
            (oldFiber = createChild(
              returnFiber,
              newChildren[newIdx],
              expirationTime
            ))
          )
            (currentFirstChild = placeChild(
              oldFiber,
              currentFirstChild,
              newIdx
            )),
              null === previousNewFiber
                ? (resultingFirstChild = oldFiber)
                : (previousNewFiber.sibling = oldFiber),
              (previousNewFiber = oldFiber);
        return resultingFirstChild;
      }
      for (
        oldFiber = mapRemainingChildren(returnFiber, oldFiber);
        newIdx < newChildren.length;
        newIdx++
      )
        if (
          (nextOldFiber = updateFromMap(
            oldFiber,
            returnFiber,
            newIdx,
            newChildren[newIdx],
            expirationTime
          ))
        )
          shouldTrackSideEffects &&
            null !== nextOldFiber.alternate &&
            oldFiber.delete(
              null === nextOldFiber.key ? newIdx : nextOldFiber.key
            ),
            (currentFirstChild = placeChild(
              nextOldFiber,
              currentFirstChild,
              newIdx
            )),
            null === previousNewFiber
              ? (resultingFirstChild = nextOldFiber)
              : (previousNewFiber.sibling = nextOldFiber),
            (previousNewFiber = nextOldFiber);
      shouldTrackSideEffects &&
        oldFiber.forEach(function(child) {
          return deleteChild(returnFiber, child);
        });
      return resultingFirstChild;
    }
    function reconcileChildrenIterator(
      returnFiber,
      currentFirstChild,
      newChildrenIterable,
      expirationTime
    ) {
      var iteratorFn = getIteratorFn(newChildrenIterable);
      "function" !== typeof iteratorFn ? reactProdInvariant("150") : void 0;
      newChildrenIterable = iteratorFn.call(newChildrenIterable);
      null == newChildrenIterable ? reactProdInvariant("151") : void 0;
      for (
        var previousNewFiber = (iteratorFn = null),
          oldFiber = currentFirstChild,
          newIdx = (currentFirstChild = 0),
          nextOldFiber = null,
          step = newChildrenIterable.next();
        null !== oldFiber && !step.done;
        newIdx++, step = newChildrenIterable.next()
      ) {
        oldFiber.index > newIdx
          ? ((nextOldFiber = oldFiber), (oldFiber = null))
          : (nextOldFiber = oldFiber.sibling);
        var newFiber = updateSlot(
          returnFiber,
          oldFiber,
          step.value,
          expirationTime
        );
        if (null === newFiber) {
          oldFiber || (oldFiber = nextOldFiber);
          break;
        }
        shouldTrackSideEffects &&
          oldFiber &&
          null === newFiber.alternate &&
          deleteChild(returnFiber, oldFiber);
        currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
        null === previousNewFiber
          ? (iteratorFn = newFiber)
          : (previousNewFiber.sibling = newFiber);
        previousNewFiber = newFiber;
        oldFiber = nextOldFiber;
      }
      if (step.done)
        return deleteRemainingChildren(returnFiber, oldFiber), iteratorFn;
      if (null === oldFiber) {
        for (; !step.done; newIdx++, step = newChildrenIterable.next())
          (step = createChild(returnFiber, step.value, expirationTime)),
            null !== step &&
              ((currentFirstChild = placeChild(
                step,
                currentFirstChild,
                newIdx
              )),
              null === previousNewFiber
                ? (iteratorFn = step)
                : (previousNewFiber.sibling = step),
              (previousNewFiber = step));
        return iteratorFn;
      }
      for (
        oldFiber = mapRemainingChildren(returnFiber, oldFiber);
        !step.done;
        newIdx++, step = newChildrenIterable.next()
      )
        (step = updateFromMap(
          oldFiber,
          returnFiber,
          newIdx,
          step.value,
          expirationTime
        )),
          null !== step &&
            (shouldTrackSideEffects &&
              null !== step.alternate &&
              oldFiber.delete(null === step.key ? newIdx : step.key),
            (currentFirstChild = placeChild(step, currentFirstChild, newIdx)),
            null === previousNewFiber
              ? (iteratorFn = step)
              : (previousNewFiber.sibling = step),
            (previousNewFiber = step));
      shouldTrackSideEffects &&
        oldFiber.forEach(function(child) {
          return deleteChild(returnFiber, child);
        });
      return iteratorFn;
    }
    return function(returnFiber, currentFirstChild, newChild, expirationTime) {
      var isUnkeyedTopLevelFragment =
        "object" === typeof newChild &&
        null !== newChild &&
        newChild.type === REACT_FRAGMENT_TYPE &&
        null === newChild.key;
      isUnkeyedTopLevelFragment && (newChild = newChild.props.children);
      var isObject = "object" === typeof newChild && null !== newChild;
      if (isObject)
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            a: {
              isObject = newChild.key;
              for (
                isUnkeyedTopLevelFragment = currentFirstChild;
                null !== isUnkeyedTopLevelFragment;

              ) {
                if (isUnkeyedTopLevelFragment.key === isObject)
                  if (
                    10 === isUnkeyedTopLevelFragment.tag
                      ? newChild.type === REACT_FRAGMENT_TYPE
                      : isUnkeyedTopLevelFragment.type === newChild.type
                  ) {
                    deleteRemainingChildren(
                      returnFiber,
                      isUnkeyedTopLevelFragment.sibling
                    );
                    currentFirstChild = useFiber(
                      isUnkeyedTopLevelFragment,
                      newChild.type === REACT_FRAGMENT_TYPE
                        ? newChild.props.children
                        : newChild.props,
                      expirationTime
                    );
                    currentFirstChild.ref = coerceRef(
                      returnFiber,
                      isUnkeyedTopLevelFragment,
                      newChild
                    );
                    currentFirstChild.return = returnFiber;
                    returnFiber = currentFirstChild;
                    break a;
                  } else {
                    deleteRemainingChildren(
                      returnFiber,
                      isUnkeyedTopLevelFragment
                    );
                    break;
                  }
                else deleteChild(returnFiber, isUnkeyedTopLevelFragment);
                isUnkeyedTopLevelFragment = isUnkeyedTopLevelFragment.sibling;
              }
              newChild.type === REACT_FRAGMENT_TYPE
                ? ((currentFirstChild = createFiberFromFragment(
                    newChild.props.children,
                    returnFiber.mode,
                    expirationTime,
                    newChild.key
                  )),
                  (currentFirstChild.return = returnFiber),
                  (returnFiber = currentFirstChild))
                : ((expirationTime = createFiberFromElement(
                    newChild,
                    returnFiber.mode,
                    expirationTime
                  )),
                  (expirationTime.ref = coerceRef(
                    returnFiber,
                    currentFirstChild,
                    newChild
                  )),
                  (expirationTime.return = returnFiber),
                  (returnFiber = expirationTime));
            }
            return placeSingleChild(returnFiber);
          case REACT_PORTAL_TYPE:
            a: {
              for (
                isUnkeyedTopLevelFragment = newChild.key;
                null !== currentFirstChild;

              ) {
                if (currentFirstChild.key === isUnkeyedTopLevelFragment)
                  if (
                    4 === currentFirstChild.tag &&
                    currentFirstChild.stateNode.containerInfo ===
                      newChild.containerInfo &&
                    currentFirstChild.stateNode.implementation ===
                      newChild.implementation
                  ) {
                    deleteRemainingChildren(
                      returnFiber,
                      currentFirstChild.sibling
                    );
                    currentFirstChild = useFiber(
                      currentFirstChild,
                      newChild.children || [],
                      expirationTime
                    );
                    currentFirstChild.return = returnFiber;
                    returnFiber = currentFirstChild;
                    break a;
                  } else {
                    deleteRemainingChildren(returnFiber, currentFirstChild);
                    break;
                  }
                else deleteChild(returnFiber, currentFirstChild);
                currentFirstChild = currentFirstChild.sibling;
              }
              currentFirstChild = createFiberFromPortal(
                newChild,
                returnFiber.mode,
                expirationTime
              );
              currentFirstChild.return = returnFiber;
              returnFiber = currentFirstChild;
            }
            return placeSingleChild(returnFiber);
        }
      if ("string" === typeof newChild || "number" === typeof newChild)
        return (
          (newChild = "" + newChild),
          null !== currentFirstChild && 6 === currentFirstChild.tag
            ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling),
              (currentFirstChild = useFiber(
                currentFirstChild,
                newChild,
                expirationTime
              )),
              (currentFirstChild.return = returnFiber),
              (returnFiber = currentFirstChild))
            : (deleteRemainingChildren(returnFiber, currentFirstChild),
              (currentFirstChild = createFiberFromText(
                newChild,
                returnFiber.mode,
                expirationTime
              )),
              (currentFirstChild.return = returnFiber),
              (returnFiber = currentFirstChild)),
          placeSingleChild(returnFiber)
        );
      if (isArray$1(newChild))
        return reconcileChildrenArray(
          returnFiber,
          currentFirstChild,
          newChild,
          expirationTime
        );
      if (getIteratorFn(newChild))
        return reconcileChildrenIterator(
          returnFiber,
          currentFirstChild,
          newChild,
          expirationTime
        );
      isObject && throwOnInvalidObjectType(returnFiber, newChild);
      if ("undefined" === typeof newChild && !isUnkeyedTopLevelFragment)
        switch (returnFiber.tag) {
          case 2:
          case 1:
            (expirationTime = returnFiber.type),
              reactProdInvariant(
                "152",
                expirationTime.displayName || expirationTime.name || "Component"
              );
        }
      return deleteRemainingChildren(returnFiber, currentFirstChild);
    };
  }
  function deleteHydratableInstance(returnFiber, instance) {
    var fiber = new FiberNode(5, null, null, 0);
    fiber.type = "DELETED";
    fiber.stateNode = instance;
    fiber.return = returnFiber;
    fiber.effectTag = 8;
    null !== returnFiber.lastEffect
      ? ((returnFiber.lastEffect.nextEffect = fiber),
        (returnFiber.lastEffect = fiber))
      : (returnFiber.firstEffect = returnFiber.lastEffect = fiber);
  }
  function tryHydrate(fiber, nextInstance) {
    switch (fiber.tag) {
      case 5:
        var type = fiber.type;
        nextInstance =
          1 !== nextInstance.nodeType ||
          type.toLowerCase() !== nextInstance.nodeName.toLowerCase()
            ? null
            : nextInstance;
        return null !== nextInstance
          ? ((fiber.stateNode = nextInstance), !0)
          : !1;
      case 6:
        return (
          (nextInstance =
            "" === fiber.pendingProps || 3 !== nextInstance.nodeType
              ? null
              : nextInstance),
          null !== nextInstance ? ((fiber.stateNode = nextInstance), !0) : !1
        );
      default:
        return !1;
    }
  }
  function tryToClaimNextHydratableInstance(fiber) {
    if (isHydrating) {
      var nextInstance = nextHydratableInstance;
      if (nextInstance) {
        var firstAttemptedInstance = nextInstance;
        if (!tryHydrate(fiber, nextInstance)) {
          nextInstance = getNextHydratableSibling(firstAttemptedInstance);
          if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
            fiber.effectTag |= 2;
            isHydrating = !1;
            hydrationParentFiber = fiber;
            return;
          }
          deleteHydratableInstance(
            hydrationParentFiber,
            firstAttemptedInstance
          );
        }
        hydrationParentFiber = fiber;
        nextHydratableInstance = getFirstHydratableChild(nextInstance);
      } else
        (fiber.effectTag |= 2),
          (isHydrating = !1),
          (hydrationParentFiber = fiber);
    }
  }
  function popToNextHostParent(fiber) {
    for (
      fiber = fiber.return;
      null !== fiber && 5 !== fiber.tag && 3 !== fiber.tag;

    )
      fiber = fiber.return;
    hydrationParentFiber = fiber;
  }
  function popHydrationState(fiber) {
    if (fiber !== hydrationParentFiber) return !1;
    if (!isHydrating) return popToNextHostParent(fiber), (isHydrating = !0), !1;
    var type = fiber.type;
    if (
      5 !== fiber.tag ||
      ("head" !== type &&
        "body" !== type &&
        !shouldSetTextContent(type, fiber.memoizedProps))
    )
      for (type = nextHydratableInstance; type; )
        deleteHydratableInstance(fiber, type),
          (type = getNextHydratableSibling(type));
    popToNextHostParent(fiber);
    nextHydratableInstance = hydrationParentFiber
      ? getNextHydratableSibling(fiber.stateNode)
      : null;
    return !0;
  }
  function resetHydrationState() {
    nextHydratableInstance = hydrationParentFiber = null;
    isHydrating = !1;
  }
  function reconcileChildren(
    current$$1,
    workInProgress,
    nextChildren,
    renderExpirationTime
  ) {
    workInProgress.child =
      null === current$$1
        ? mountChildFibers(
            workInProgress,
            null,
            nextChildren,
            renderExpirationTime
          )
        : reconcileChildFibers(
            workInProgress,
            current$$1.child,
            nextChildren,
            renderExpirationTime
          );
  }
  function markRef(current$$1, workInProgress) {
    var ref = workInProgress.ref;
    if (
      (null === current$$1 && null !== ref) ||
      (null !== current$$1 && current$$1.ref !== ref)
    )
      workInProgress.effectTag |= 128;
  }
  function finishClassComponent(
    current$$1,
    workInProgress,
    shouldUpdate,
    hasContext,
    renderExpirationTime
  ) {
    markRef(current$$1, workInProgress);
    var didCaptureError = 0 !== (workInProgress.effectTag & 64);
    if (!shouldUpdate && !didCaptureError)
      return (
        hasContext && invalidateContextProvider(workInProgress, !1),
        bailoutOnAlreadyFinishedWork(
          current$$1,
          workInProgress,
          renderExpirationTime
        )
      );
    shouldUpdate = workInProgress.stateNode;
    ReactCurrentOwner$3.current = workInProgress;
    var nextChildren = didCaptureError ? null : shouldUpdate.render();
    workInProgress.effectTag |= 1;
    null !== current$$1 &&
      didCaptureError &&
      (reconcileChildren(
        current$$1,
        workInProgress,
        null,
        renderExpirationTime
      ),
      (workInProgress.child = null));
    reconcileChildren(
      current$$1,
      workInProgress,
      nextChildren,
      renderExpirationTime
    );
    workInProgress.memoizedState = shouldUpdate.state;
    workInProgress.memoizedProps = shouldUpdate.props;
    hasContext && invalidateContextProvider(workInProgress, !0);
    return workInProgress.child;
  }
  function pushHostRootContext(workInProgress) {
    var root = workInProgress.stateNode;
    root.pendingContext
      ? pushTopLevelContextObject(
          workInProgress,
          root.pendingContext,
          root.pendingContext !== root.context
        )
      : root.context &&
        pushTopLevelContextObject(workInProgress, root.context, !1);
    pushHostContainer(workInProgress, root.containerInfo);
  }
  function bailoutOnAlreadyFinishedWork(
    current$$1,
    workInProgress,
    renderExpirationTime
  ) {
    null !== current$$1 &&
      (workInProgress.firstContextDependency =
        current$$1.firstContextDependency);
    var childExpirationTime = workInProgress.childExpirationTime;
    if (0 === childExpirationTime || childExpirationTime > renderExpirationTime)
      return null;
    null !== current$$1 && workInProgress.child !== current$$1.child
      ? reactProdInvariant("153")
      : void 0;
    if (null !== workInProgress.child) {
      current$$1 = workInProgress.child;
      renderExpirationTime = createWorkInProgress(
        current$$1,
        current$$1.pendingProps,
        current$$1.expirationTime
      );
      workInProgress.child = renderExpirationTime;
      for (
        renderExpirationTime.return = workInProgress;
        null !== current$$1.sibling;

      )
        (current$$1 = current$$1.sibling),
          (renderExpirationTime = renderExpirationTime.sibling = createWorkInProgress(
            current$$1,
            current$$1.pendingProps,
            current$$1.expirationTime
          )),
          (renderExpirationTime.return = workInProgress);
      renderExpirationTime.sibling = null;
    }
    return workInProgress.child;
  }
  function beginWork(current$$1, workInProgress, renderExpirationTime) {
    var updateExpirationTime = workInProgress.expirationTime;
    if (
      !didPerformWorkStackCursor.current &&
      (0 === updateExpirationTime ||
        updateExpirationTime > renderExpirationTime)
    ) {
      switch (workInProgress.tag) {
        case 3:
          pushHostRootContext(workInProgress);
          resetHydrationState();
          break;
        case 5:
          pushHostContext(workInProgress);
          break;
        case 2:
          pushContextProvider(workInProgress);
          break;
        case 4:
          pushHostContainer(
            workInProgress,
            workInProgress.stateNode.containerInfo
          );
          break;
        case 13:
          (workInProgress.stateNode = 0), pushProvider(workInProgress);
      }
      return bailoutOnAlreadyFinishedWork(
        current$$1,
        workInProgress,
        renderExpirationTime
      );
    }
    workInProgress.expirationTime = 0;
    switch (workInProgress.tag) {
      case 0:
        null !== current$$1 ? reactProdInvariant("155") : void 0;
        var fn = workInProgress.type;
        updateExpirationTime = workInProgress.pendingProps;
        var unmaskedContext = getUnmaskedContext(workInProgress);
        unmaskedContext = getMaskedContext(workInProgress, unmaskedContext);
        prepareToReadContext(workInProgress, renderExpirationTime);
        fn = fn(updateExpirationTime, unmaskedContext);
        workInProgress.effectTag |= 1;
        "object" === typeof fn &&
        null !== fn &&
        "function" === typeof fn.render &&
        void 0 === fn.$$typeof
          ? ((unmaskedContext = workInProgress.type),
            (workInProgress.tag = 2),
            (workInProgress.memoizedState =
              null !== fn.state && void 0 !== fn.state ? fn.state : null),
            (unmaskedContext = unmaskedContext.getDerivedStateFromProps),
            "function" === typeof unmaskedContext &&
              applyDerivedStateFromProps(
                workInProgress,
                unmaskedContext,
                updateExpirationTime
              ),
            (updateExpirationTime = pushContextProvider(workInProgress)),
            (fn.updater = classComponentUpdater),
            (workInProgress.stateNode = fn),
            (fn._reactInternalFiber = workInProgress),
            mountClassInstance(workInProgress, renderExpirationTime),
            (current$$1 = finishClassComponent(
              current$$1,
              workInProgress,
              !0,
              updateExpirationTime,
              renderExpirationTime
            )))
          : ((workInProgress.tag = 1),
            reconcileChildren(
              current$$1,
              workInProgress,
              fn,
              renderExpirationTime
            ),
            (workInProgress.memoizedProps = updateExpirationTime),
            (current$$1 = workInProgress.child));
        return current$$1;
      case 1:
        return (
          (fn = workInProgress.type),
          (updateExpirationTime = workInProgress.pendingProps),
          (unmaskedContext = getUnmaskedContext(workInProgress)),
          (unmaskedContext = getMaskedContext(workInProgress, unmaskedContext)),
          prepareToReadContext(workInProgress, renderExpirationTime),
          (fn = fn(updateExpirationTime, unmaskedContext)),
          (workInProgress.effectTag |= 1),
          reconcileChildren(
            current$$1,
            workInProgress,
            fn,
            renderExpirationTime
          ),
          (workInProgress.memoizedProps = updateExpirationTime),
          workInProgress.child
        );
      case 2:
        updateExpirationTime = pushContextProvider(workInProgress);
        fn = prepareToReadContext(workInProgress, renderExpirationTime);
        if (null === current$$1)
          if (null === workInProgress.stateNode) {
            var props = workInProgress.pendingProps,
              ctor = workInProgress.type;
            fn = getUnmaskedContext(workInProgress);
            var needsContext =
              2 === workInProgress.tag &&
              null != workInProgress.type.contextTypes;
            unmaskedContext = needsContext
              ? getMaskedContext(workInProgress, fn)
              : emptyContextObject;
            props = new ctor(props, unmaskedContext);
            workInProgress.memoizedState =
              null !== props.state && void 0 !== props.state
                ? props.state
                : null;
            props.updater = classComponentUpdater;
            workInProgress.stateNode = props;
            props._reactInternalFiber = workInProgress;
            needsContext &&
              ((needsContext = workInProgress.stateNode),
              (needsContext.__reactInternalMemoizedUnmaskedChildContext = fn),
              (needsContext.__reactInternalMemoizedMaskedChildContext = unmaskedContext));
            mountClassInstance(workInProgress, renderExpirationTime);
            fn = !0;
          } else {
            var ctor$jscomp$0 = workInProgress.type;
            unmaskedContext = workInProgress.stateNode;
            props = workInProgress.memoizedProps;
            needsContext = workInProgress.pendingProps;
            unmaskedContext.props = props;
            var oldContext = unmaskedContext.context;
            ctor = getUnmaskedContext(workInProgress);
            ctor = getMaskedContext(workInProgress, ctor);
            var getDerivedStateFromProps =
              ctor$jscomp$0.getDerivedStateFromProps;
            (ctor$jscomp$0 =
              "function" === typeof getDerivedStateFromProps ||
              "function" === typeof unmaskedContext.getSnapshotBeforeUpdate) ||
              ("function" !==
                typeof unmaskedContext.UNSAFE_componentWillReceiveProps &&
                "function" !==
                  typeof unmaskedContext.componentWillReceiveProps) ||
              ((props !== needsContext || oldContext !== ctor) &&
                callComponentWillReceiveProps(
                  workInProgress,
                  unmaskedContext,
                  needsContext,
                  ctor
                ));
            hasForceUpdate = !1;
            var oldState = workInProgress.memoizedState;
            oldContext = unmaskedContext.state = oldState;
            var updateQueue = workInProgress.updateQueue;
            null !== updateQueue &&
              (processUpdateQueue(
                workInProgress,
                updateQueue,
                needsContext,
                unmaskedContext,
                renderExpirationTime
              ),
              (oldContext = workInProgress.memoizedState));
            props !== needsContext ||
            oldState !== oldContext ||
            didPerformWorkStackCursor.current ||
            fn ||
            hasForceUpdate
              ? ("function" === typeof getDerivedStateFromProps &&
                  (applyDerivedStateFromProps(
                    workInProgress,
                    getDerivedStateFromProps,
                    needsContext
                  ),
                  (oldContext = workInProgress.memoizedState)),
                (fn =
                  hasForceUpdate ||
                  fn ||
                  checkShouldComponentUpdate(
                    workInProgress,
                    props,
                    needsContext,
                    oldState,
                    oldContext,
                    ctor
                  ))
                  ? (ctor$jscomp$0 ||
                      ("function" !==
                        typeof unmaskedContext.UNSAFE_componentWillMount &&
                        "function" !==
                          typeof unmaskedContext.componentWillMount) ||
                      ("function" ===
                        typeof unmaskedContext.componentWillMount &&
                        unmaskedContext.componentWillMount(),
                      "function" ===
                        typeof unmaskedContext.UNSAFE_componentWillMount &&
                        unmaskedContext.UNSAFE_componentWillMount()),
                    "function" === typeof unmaskedContext.componentDidMount &&
                      (workInProgress.effectTag |= 4))
                  : ("function" === typeof unmaskedContext.componentDidMount &&
                      (workInProgress.effectTag |= 4),
                    (workInProgress.memoizedProps = needsContext),
                    (workInProgress.memoizedState = oldContext)),
                (unmaskedContext.props = needsContext),
                (unmaskedContext.state = oldContext),
                (unmaskedContext.context = ctor))
              : ("function" === typeof unmaskedContext.componentDidMount &&
                  (workInProgress.effectTag |= 4),
                (fn = !1));
          }
        else
          (ctor$jscomp$0 = workInProgress.type),
            (unmaskedContext = workInProgress.stateNode),
            (needsContext = workInProgress.memoizedProps),
            (props = workInProgress.pendingProps),
            (unmaskedContext.props = needsContext),
            (oldContext = unmaskedContext.context),
            (ctor = getUnmaskedContext(workInProgress)),
            (ctor = getMaskedContext(workInProgress, ctor)),
            (getDerivedStateFromProps = ctor$jscomp$0.getDerivedStateFromProps),
            (ctor$jscomp$0 =
              "function" === typeof getDerivedStateFromProps ||
              "function" === typeof unmaskedContext.getSnapshotBeforeUpdate) ||
              ("function" !==
                typeof unmaskedContext.UNSAFE_componentWillReceiveProps &&
                "function" !==
                  typeof unmaskedContext.componentWillReceiveProps) ||
              ((needsContext !== props || oldContext !== ctor) &&
                callComponentWillReceiveProps(
                  workInProgress,
                  unmaskedContext,
                  props,
                  ctor
                )),
            (hasForceUpdate = !1),
            (oldContext = workInProgress.memoizedState),
            (oldState = unmaskedContext.state = oldContext),
            (updateQueue = workInProgress.updateQueue),
            null !== updateQueue &&
              (processUpdateQueue(
                workInProgress,
                updateQueue,
                props,
                unmaskedContext,
                renderExpirationTime
              ),
              (oldState = workInProgress.memoizedState)),
            needsContext !== props ||
            oldContext !== oldState ||
            didPerformWorkStackCursor.current ||
            fn ||
            hasForceUpdate
              ? ("function" === typeof getDerivedStateFromProps &&
                  (applyDerivedStateFromProps(
                    workInProgress,
                    getDerivedStateFromProps,
                    props
                  ),
                  (oldState = workInProgress.memoizedState)),
                (fn =
                  hasForceUpdate ||
                  fn ||
                  checkShouldComponentUpdate(
                    workInProgress,
                    needsContext,
                    props,
                    oldContext,
                    oldState,
                    ctor
                  ))
                  ? (ctor$jscomp$0 ||
                      ("function" !==
                        typeof unmaskedContext.UNSAFE_componentWillUpdate &&
                        "function" !==
                          typeof unmaskedContext.componentWillUpdate) ||
                      ("function" ===
                        typeof unmaskedContext.componentWillUpdate &&
                        unmaskedContext.componentWillUpdate(
                          props,
                          oldState,
                          ctor
                        ),
                      "function" ===
                        typeof unmaskedContext.UNSAFE_componentWillUpdate &&
                        unmaskedContext.UNSAFE_componentWillUpdate(
                          props,
                          oldState,
                          ctor
                        )),
                    "function" === typeof unmaskedContext.componentDidUpdate &&
                      (workInProgress.effectTag |= 4),
                    "function" ===
                      typeof unmaskedContext.getSnapshotBeforeUpdate &&
                      (workInProgress.effectTag |= 256))
                  : ("function" !== typeof unmaskedContext.componentDidUpdate ||
                      (needsContext === current$$1.memoizedProps &&
                        oldContext === current$$1.memoizedState) ||
                      (workInProgress.effectTag |= 4),
                    "function" !==
                      typeof unmaskedContext.getSnapshotBeforeUpdate ||
                      (needsContext === current$$1.memoizedProps &&
                        oldContext === current$$1.memoizedState) ||
                      (workInProgress.effectTag |= 256),
                    (workInProgress.memoizedProps = props),
                    (workInProgress.memoizedState = oldState)),
                (unmaskedContext.props = props),
                (unmaskedContext.state = oldState),
                (unmaskedContext.context = ctor))
              : ("function" !== typeof unmaskedContext.componentDidUpdate ||
                  (needsContext === current$$1.memoizedProps &&
                    oldContext === current$$1.memoizedState) ||
                  (workInProgress.effectTag |= 4),
                "function" !== typeof unmaskedContext.getSnapshotBeforeUpdate ||
                  (needsContext === current$$1.memoizedProps &&
                    oldContext === current$$1.memoizedState) ||
                  (workInProgress.effectTag |= 256),
                (fn = !1));
        return finishClassComponent(
          current$$1,
          workInProgress,
          fn,
          updateExpirationTime,
          renderExpirationTime
        );
      case 3:
        pushHostRootContext(workInProgress);
        updateExpirationTime = workInProgress.updateQueue;
        null === updateExpirationTime
          ? invariant(
              !1,
              "If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue."
            )
          : void 0;
        fn = workInProgress.memoizedState;
        fn = null !== fn ? fn.element : null;
        processUpdateQueue(
          workInProgress,
          updateExpirationTime,
          workInProgress.pendingProps,
          null,
          renderExpirationTime
        );
        updateExpirationTime = workInProgress.memoizedState.element;
        if (updateExpirationTime === fn)
          resetHydrationState(),
            (current$$1 = bailoutOnAlreadyFinishedWork(
              current$$1,
              workInProgress,
              renderExpirationTime
            ));
        else {
          fn = workInProgress.stateNode;
          if (
            (fn =
              (null === current$$1 || null === current$$1.child) && fn.hydrate)
          )
            (nextHydratableInstance = getFirstHydratableChild(
              workInProgress.stateNode.containerInfo
            )),
              (hydrationParentFiber = workInProgress),
              (fn = isHydrating = !0);
          fn
            ? ((workInProgress.effectTag |= 2),
              (workInProgress.child = mountChildFibers(
                workInProgress,
                null,
                updateExpirationTime,
                renderExpirationTime
              )))
            : (reconcileChildren(
                current$$1,
                workInProgress,
                updateExpirationTime,
                renderExpirationTime
              ),
              resetHydrationState());
          current$$1 = workInProgress.child;
        }
        return current$$1;
      case 5:
        return (
          pushHostContext(workInProgress),
          null === current$$1 &&
            tryToClaimNextHydratableInstance(workInProgress),
          (updateExpirationTime = workInProgress.type),
          (fn = workInProgress.pendingProps),
          (unmaskedContext =
            null !== current$$1 ? current$$1.memoizedProps : null),
          (needsContext = fn.children),
          shouldSetTextContent(updateExpirationTime, fn)
            ? (needsContext = null)
            : null !== unmaskedContext &&
              shouldSetTextContent(updateExpirationTime, unmaskedContext) &&
              (workInProgress.effectTag |= 16),
          markRef(current$$1, workInProgress),
          1073741823 !== renderExpirationTime &&
          workInProgress.mode & 1 &&
          fn.hidden
            ? ((workInProgress.expirationTime = 1073741823),
              (workInProgress.memoizedProps = fn),
              (current$$1 = null))
            : (reconcileChildren(
                current$$1,
                workInProgress,
                needsContext,
                renderExpirationTime
              ),
              (workInProgress.memoizedProps = fn),
              (current$$1 = workInProgress.child)),
          current$$1
        );
      case 6:
        return (
          null === current$$1 &&
            tryToClaimNextHydratableInstance(workInProgress),
          (workInProgress.memoizedProps = workInProgress.pendingProps),
          null
        );
      case 16:
        return null;
      case 4:
        return (
          pushHostContainer(
            workInProgress,
            workInProgress.stateNode.containerInfo
          ),
          (updateExpirationTime = workInProgress.pendingProps),
          null === current$$1
            ? (workInProgress.child = reconcileChildFibers(
                workInProgress,
                null,
                updateExpirationTime,
                renderExpirationTime
              ))
            : reconcileChildren(
                current$$1,
                workInProgress,
                updateExpirationTime,
                renderExpirationTime
              ),
          (workInProgress.memoizedProps = updateExpirationTime),
          workInProgress.child
        );
      case 14:
        return (
          (fn = workInProgress.type.render),
          (updateExpirationTime = workInProgress.pendingProps),
          (unmaskedContext = workInProgress.ref),
          didPerformWorkStackCursor.current ||
          workInProgress.memoizedProps !== updateExpirationTime ||
          unmaskedContext !== (null !== current$$1 ? current$$1.ref : null)
            ? ((fn = fn(updateExpirationTime, unmaskedContext)),
              reconcileChildren(
                current$$1,
                workInProgress,
                fn,
                renderExpirationTime
              ),
              (workInProgress.memoizedProps = updateExpirationTime),
              (current$$1 = workInProgress.child))
            : (current$$1 = bailoutOnAlreadyFinishedWork(
                current$$1,
                workInProgress,
                renderExpirationTime
              )),
          current$$1
        );
      case 10:
        return (
          (updateExpirationTime = workInProgress.pendingProps),
          reconcileChildren(
            current$$1,
            workInProgress,
            updateExpirationTime,
            renderExpirationTime
          ),
          (workInProgress.memoizedProps = updateExpirationTime),
          workInProgress.child
        );
      case 11:
        return (
          (updateExpirationTime = workInProgress.pendingProps.children),
          reconcileChildren(
            current$$1,
            workInProgress,
            updateExpirationTime,
            renderExpirationTime
          ),
          (workInProgress.memoizedProps = updateExpirationTime),
          workInProgress.child
        );
      case 15:
        return (
          (updateExpirationTime = workInProgress.pendingProps),
          reconcileChildren(
            current$$1,
            workInProgress,
            updateExpirationTime.children,
            renderExpirationTime
          ),
          (workInProgress.memoizedProps = updateExpirationTime),
          workInProgress.child
        );
      case 13:
        a: {
          updateExpirationTime = workInProgress.type._context;
          fn = workInProgress.pendingProps;
          unmaskedContext = workInProgress.memoizedProps;
          needsContext = fn.value;
          workInProgress.memoizedProps = fn;
          if (null === unmaskedContext) needsContext = 1073741823;
          else if (unmaskedContext.value === fn.value) {
            if (
              unmaskedContext.children === fn.children &&
              !didPerformWorkStackCursor.current
            ) {
              workInProgress.stateNode = 0;
              pushProvider(workInProgress);
              current$$1 = bailoutOnAlreadyFinishedWork(
                current$$1,
                workInProgress,
                renderExpirationTime
              );
              break a;
            }
            needsContext = 0;
          } else if (
            ((props = unmaskedContext.value),
            (props === needsContext &&
              (0 !== props || 1 / props === 1 / needsContext)) ||
              (props !== props && needsContext !== needsContext))
          ) {
            if (
              unmaskedContext.children === fn.children &&
              !didPerformWorkStackCursor.current
            ) {
              workInProgress.stateNode = 0;
              pushProvider(workInProgress);
              current$$1 = bailoutOnAlreadyFinishedWork(
                current$$1,
                workInProgress,
                renderExpirationTime
              );
              break a;
            }
            needsContext = 0;
          } else if (
            ((needsContext =
              "function" === typeof updateExpirationTime._calculateChangedBits
                ? updateExpirationTime._calculateChangedBits(
                    props,
                    needsContext
                  )
                : 1073741823),
            (needsContext |= 0),
            0 === needsContext)
          ) {
            if (
              unmaskedContext.children === fn.children &&
              !didPerformWorkStackCursor.current
            ) {
              workInProgress.stateNode = 0;
              pushProvider(workInProgress);
              current$$1 = bailoutOnAlreadyFinishedWork(
                current$$1,
                workInProgress,
                renderExpirationTime
              );
              break a;
            }
          } else
            propagateContextChange(
              workInProgress,
              updateExpirationTime,
              needsContext,
              renderExpirationTime
            );
          workInProgress.stateNode = needsContext;
          pushProvider(workInProgress);
          reconcileChildren(
            current$$1,
            workInProgress,
            fn.children,
            renderExpirationTime
          );
          current$$1 = workInProgress.child;
        }
        return current$$1;
      case 12:
        return (
          (unmaskedContext = workInProgress.type),
          (updateExpirationTime = workInProgress.pendingProps),
          (fn = updateExpirationTime.children),
          prepareToReadContext(workInProgress, renderExpirationTime),
          (unmaskedContext = readContext(
            unmaskedContext,
            updateExpirationTime.unstable_observedBits
          )),
          (fn = fn(unmaskedContext)),
          (workInProgress.effectTag |= 1),
          reconcileChildren(
            current$$1,
            workInProgress,
            fn,
            renderExpirationTime
          ),
          (workInProgress.memoizedProps = updateExpirationTime),
          workInProgress.child
        );
      default:
        reactProdInvariant("156");
    }
  }
  function markUpdate(workInProgress) {
    workInProgress.effectTag |= 4;
  }
  function logError(boundary, errorInfo) {
    var source = errorInfo.source;
    null === errorInfo.stack &&
      null !== source &&
      getStackByFiberInDevAndProd(source);
    null !== source && getComponentName(source.type);
    errorInfo = errorInfo.value;
    null !== boundary && 2 === boundary.tag && getComponentName(boundary.type);
    try {
      (errorInfo && errorInfo.suppressReactErrorLogging) ||
        console.error(errorInfo);
    } catch (e) {
      (e && e.suppressReactErrorLogging) || console.error(e);
    }
  }
  function safelyDetachRef(current$$1) {
    var ref = current$$1.ref;
    if (null !== ref)
      if ("function" === typeof ref)
        try {
          ref(null);
        } catch (refError) {
          captureCommitPhaseError(current$$1, refError);
        }
      else ref.current = null;
  }
  function commitUnmount(current$$1) {
    "function" === typeof onCommitFiberUnmount &&
      onCommitFiberUnmount(current$$1);
    switch (current$$1.tag) {
      case 2:
        safelyDetachRef(current$$1);
        var instance = current$$1.stateNode;
        if ("function" === typeof instance.componentWillUnmount)
          try {
            (instance.props = current$$1.memoizedProps),
              (instance.state = current$$1.memoizedState),
              instance.componentWillUnmount();
          } catch (unmountError) {
            captureCommitPhaseError(current$$1, unmountError);
          }
        break;
      case 5:
        safelyDetachRef(current$$1);
        break;
      case 4:
        unmountHostComponents(current$$1);
    }
  }
  function isHostParent(fiber) {
    return 5 === fiber.tag || 3 === fiber.tag || 4 === fiber.tag;
  }
  function commitPlacement(finishedWork) {
    a: {
      for (var parent = finishedWork.return; null !== parent; ) {
        if (isHostParent(parent)) {
          var parentFiber = parent;
          break a;
        }
        parent = parent.return;
      }
      reactProdInvariant("160");
      parentFiber = void 0;
    }
    var isContainer = (parent = void 0);
    switch (parentFiber.tag) {
      case 5:
        parent = parentFiber.stateNode;
        isContainer = !1;
        break;
      case 3:
        parent = parentFiber.stateNode.containerInfo;
        isContainer = !0;
        break;
      case 4:
        parent = parentFiber.stateNode.containerInfo;
        isContainer = !0;
        break;
      default:
        reactProdInvariant("161");
    }
    parentFiber.effectTag & 16 &&
      (setTextContent(parent, ""), (parentFiber.effectTag &= -17));
    a: b: for (parentFiber = finishedWork; ; ) {
      for (; null === parentFiber.sibling; ) {
        if (null === parentFiber.return || isHostParent(parentFiber.return)) {
          parentFiber = null;
          break a;
        }
        parentFiber = parentFiber.return;
      }
      parentFiber.sibling.return = parentFiber.return;
      for (
        parentFiber = parentFiber.sibling;
        5 !== parentFiber.tag && 6 !== parentFiber.tag;

      ) {
        if (parentFiber.effectTag & 2) continue b;
        if (null === parentFiber.child || 4 === parentFiber.tag) continue b;
        else
          (parentFiber.child.return = parentFiber),
            (parentFiber = parentFiber.child);
      }
      if (!(parentFiber.effectTag & 2)) {
        parentFiber = parentFiber.stateNode;
        break a;
      }
    }
    for (var node = finishedWork; ; ) {
      if (5 === node.tag || 6 === node.tag)
        if (parentFiber)
          if (isContainer) {
            var container = parent,
              child = node.stateNode,
              beforeChild = parentFiber;
            8 === container.nodeType
              ? container.parentNode.insertBefore(child, beforeChild)
              : container.insertBefore(child, beforeChild);
          } else parent.insertBefore(node.stateNode, parentFiber);
        else
          isContainer
            ? ((container = parent),
              (child = node.stateNode),
              8 === container.nodeType
                ? container.parentNode.insertBefore(child, container)
                : container.appendChild(child))
            : parent.appendChild(node.stateNode);
      else if (4 !== node.tag && null !== node.child) {
        node.child.return = node;
        node = node.child;
        continue;
      }
      if (node === finishedWork) break;
      for (; null === node.sibling; ) {
        if (null === node.return || node.return === finishedWork) return;
        node = node.return;
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
  }
  function unmountHostComponents(current$$1) {
    for (
      var node = current$$1,
        currentParentIsValid = !1,
        currentParent = void 0,
        currentParentIsContainer = void 0;
      ;

    ) {
      if (!currentParentIsValid) {
        currentParentIsValid = node.return;
        a: for (;;) {
          null === currentParentIsValid ? reactProdInvariant("160") : void 0;
          switch (currentParentIsValid.tag) {
            case 5:
              currentParent = currentParentIsValid.stateNode;
              currentParentIsContainer = !1;
              break a;
            case 3:
              currentParent = currentParentIsValid.stateNode.containerInfo;
              currentParentIsContainer = !0;
              break a;
            case 4:
              currentParent = currentParentIsValid.stateNode.containerInfo;
              currentParentIsContainer = !0;
              break a;
          }
          currentParentIsValid = currentParentIsValid.return;
        }
        currentParentIsValid = !0;
      }
      if (5 === node.tag || 6 === node.tag) {
        a: for (var root = node, node$jscomp$0 = root; ; )
          if (
            (commitUnmount(node$jscomp$0),
            null !== node$jscomp$0.child && 4 !== node$jscomp$0.tag)
          )
            (node$jscomp$0.child.return = node$jscomp$0),
              (node$jscomp$0 = node$jscomp$0.child);
          else {
            if (node$jscomp$0 === root) break;
            for (; null === node$jscomp$0.sibling; ) {
              if (
                null === node$jscomp$0.return ||
                node$jscomp$0.return === root
              )
                break a;
              node$jscomp$0 = node$jscomp$0.return;
            }
            node$jscomp$0.sibling.return = node$jscomp$0.return;
            node$jscomp$0 = node$jscomp$0.sibling;
          }
        currentParentIsContainer
          ? ((root = currentParent),
            (node$jscomp$0 = node.stateNode),
            8 === root.nodeType
              ? root.parentNode.removeChild(node$jscomp$0)
              : root.removeChild(node$jscomp$0))
          : currentParent.removeChild(node.stateNode);
      } else if (
        (4 === node.tag
          ? ((currentParent = node.stateNode.containerInfo),
            (currentParentIsContainer = !0))
          : commitUnmount(node),
        null !== node.child)
      ) {
        node.child.return = node;
        node = node.child;
        continue;
      }
      if (node === current$$1) break;
      for (; null === node.sibling; ) {
        if (null === node.return || node.return === current$$1) return;
        node = node.return;
        4 === node.tag && (currentParentIsValid = !1);
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
  }
  function commitWork(current$$1, finishedWork) {
    switch (finishedWork.tag) {
      case 2:
        break;
      case 5:
        var instance = finishedWork.stateNode;
        if (null != instance) {
          var newProps = finishedWork.memoizedProps;
          current$$1 =
            null !== current$$1 ? current$$1.memoizedProps : newProps;
          var type = finishedWork.type,
            updatePayload = finishedWork.updateQueue;
          finishedWork.updateQueue = null;
          null !== updatePayload &&
            (updateFiberProps$1(instance, newProps),
            updateProperties(
              instance,
              updatePayload,
              type,
              current$$1,
              newProps
            ));
        }
        break;
      case 6:
        null === finishedWork.stateNode ? reactProdInvariant("162") : void 0;
        finishedWork.stateNode.nodeValue = finishedWork.memoizedProps;
        break;
      case 3:
        break;
      case 15:
        break;
      case 16:
        break;
      default:
        reactProdInvariant("163");
    }
  }
  function createRootErrorUpdate(fiber, errorInfo, expirationTime) {
    expirationTime = createUpdate(expirationTime);
    expirationTime.tag = 3;
    expirationTime.payload = { element: null };
    var error = errorInfo.value;
    expirationTime.callback = function() {
      onUncaughtError(error);
      logError(fiber, errorInfo);
    };
    return expirationTime;
  }
  function createClassErrorUpdate(fiber, errorInfo, expirationTime) {
    expirationTime = createUpdate(expirationTime);
    expirationTime.tag = 3;
    var inst = fiber.stateNode;
    null !== inst &&
      "function" === typeof inst.componentDidCatch &&
      (expirationTime.callback = function() {
        null === legacyErrorBoundariesThatAlreadyFailed
          ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))
          : legacyErrorBoundariesThatAlreadyFailed.add(this);
        var error = errorInfo.value,
          stack = errorInfo.stack;
        logError(fiber, errorInfo);
        this.componentDidCatch(error, {
          componentStack: null !== stack ? stack : ""
        });
      });
    return expirationTime;
  }
  function unwindWork(workInProgress, renderExpirationTime) {
    switch (workInProgress.tag) {
      case 2:
        return (
          popContextProvider(workInProgress),
          (renderExpirationTime = workInProgress.effectTag),
          renderExpirationTime & 1024
            ? ((workInProgress.effectTag = (renderExpirationTime & -1025) | 64),
              workInProgress)
            : null
        );
      case 3:
        return (
          popHostContainer(workInProgress),
          popTopLevelContextObject(workInProgress),
          (renderExpirationTime = workInProgress.effectTag),
          0 !== (renderExpirationTime & 64)
            ? invariant(
                !1,
                "The root failed to unmount after an error. This is likely a bug in React. Please file an issue."
              )
            : void 0,
          (workInProgress.effectTag = (renderExpirationTime & -1025) | 64),
          workInProgress
        );
      case 5:
        return popHostContext(workInProgress), null;
      case 16:
        return (
          (renderExpirationTime = workInProgress.effectTag),
          renderExpirationTime & 1024
            ? ((workInProgress.effectTag = (renderExpirationTime & -1025) | 64),
              workInProgress)
            : null
        );
      case 4:
        return popHostContainer(workInProgress), null;
      case 13:
        return popProvider(workInProgress), null;
      default:
        return null;
    }
  }
  function resetStack() {
    if (null !== nextUnitOfWork)
      for (
        var interruptedWork = nextUnitOfWork.return;
        null !== interruptedWork;

      ) {
        var interruptedWork$jscomp$0 = interruptedWork;
        switch (interruptedWork$jscomp$0.tag) {
          case 2:
            popContextProvider(interruptedWork$jscomp$0);
            break;
          case 3:
            popHostContainer(interruptedWork$jscomp$0);
            popTopLevelContextObject(interruptedWork$jscomp$0);
            break;
          case 5:
            popHostContext(interruptedWork$jscomp$0);
            break;
          case 4:
            popHostContainer(interruptedWork$jscomp$0);
            break;
          case 13:
            popProvider(interruptedWork$jscomp$0);
        }
        interruptedWork = interruptedWork.return;
      }
    nextRoot = null;
    nextRenderExpirationTime = 0;
    nextRenderDidError = !1;
    nextUnitOfWork = null;
  }
  function completeUnitOfWork(workInProgress) {
    for (;;) {
      var current$$1 = workInProgress.alternate,
        returnFiber = workInProgress.return,
        siblingFiber = workInProgress.sibling;
      if (0 === (workInProgress.effectTag & 512)) {
        var current = current$$1;
        current$$1 = workInProgress;
        var newProps = current$$1.pendingProps;
        switch (current$$1.tag) {
          case 1:
            break;
          case 2:
            popContextProvider(current$$1);
            break;
          case 3:
            popHostContainer(current$$1);
            popTopLevelContextObject(current$$1);
            var fiberRoot = current$$1.stateNode;
            fiberRoot.pendingContext &&
              ((fiberRoot.context = fiberRoot.pendingContext),
              (fiberRoot.pendingContext = null));
            if (null === current || null === current.child)
              popHydrationState(current$$1), (current$$1.effectTag &= -3);
            updateHostContainer(current$$1);
            break;
          case 5:
            popHostContext(current$$1);
            fiberRoot = requiredContext(rootInstanceStackCursor.current);
            var type = current$$1.type;
            if (null !== current && null != current$$1.stateNode) {
              var oldProps = current.memoizedProps,
                instance = current$$1.stateNode,
                currentHostContext = requiredContext(
                  contextStackCursor$1.current
                );
              instance = diffProperties(
                instance,
                type,
                oldProps,
                newProps,
                fiberRoot
              );
              updateHostComponent$1(
                current,
                current$$1,
                instance,
                type,
                oldProps,
                newProps,
                fiberRoot,
                currentHostContext
              );
              current.ref !== current$$1.ref && (current$$1.effectTag |= 128);
            } else if (newProps) {
              current = requiredContext(contextStackCursor$1.current);
              if (popHydrationState(current$$1))
                (newProps = current$$1),
                  (type = newProps.stateNode),
                  (oldProps = newProps.type),
                  (currentHostContext = newProps.memoizedProps),
                  precacheFiberNode$1(newProps, type),
                  updateFiberProps$1(type, currentHostContext),
                  (fiberRoot = diffHydratedProperties(
                    type,
                    oldProps,
                    currentHostContext,
                    current,
                    fiberRoot
                  )),
                  (newProps.updateQueue = fiberRoot),
                  null !== fiberRoot && markUpdate(current$$1);
              else {
                oldProps = newProps;
                currentHostContext = current$$1;
                current = createElement(type, oldProps, fiberRoot, current);
                precacheFiberNode$1(currentHostContext, current);
                updateFiberProps$1(current, oldProps);
                a: for (
                  oldProps = current,
                    currentHostContext = current$$1,
                    instance = currentHostContext.child;
                  null !== instance;

                ) {
                  if (5 === instance.tag || 6 === instance.tag)
                    oldProps.appendChild(instance.stateNode);
                  else if (4 !== instance.tag && null !== instance.child) {
                    instance.child.return = instance;
                    instance = instance.child;
                    continue;
                  }
                  if (instance === currentHostContext) break;
                  for (; null === instance.sibling; ) {
                    if (
                      null === instance.return ||
                      instance.return === currentHostContext
                    )
                      break a;
                    instance = instance.return;
                  }
                  instance.sibling.return = instance.return;
                  instance = instance.sibling;
                }
                setInitialProperties(current, type, newProps, fiberRoot);
                shouldAutoFocusHostComponent(type, newProps) &&
                  markUpdate(current$$1);
                current$$1.stateNode = current;
              }
              null !== current$$1.ref && (current$$1.effectTag |= 128);
            } else
              null === current$$1.stateNode
                ? reactProdInvariant("166")
                : void 0;
            break;
          case 6:
            fiberRoot = newProps;
            current && null != current$$1.stateNode
              ? updateHostText$1(
                  current,
                  current$$1,
                  current.memoizedProps,
                  fiberRoot
                )
              : ("string" !== typeof fiberRoot &&
                  (null === current$$1.stateNode
                    ? reactProdInvariant("166")
                    : void 0),
                (type = requiredContext(rootInstanceStackCursor.current)),
                requiredContext(contextStackCursor$1.current),
                popHydrationState(current$$1)
                  ? ((fiberRoot = current$$1.stateNode),
                    (newProps = current$$1.memoizedProps),
                    precacheFiberNode$1(current$$1, fiberRoot),
                    diffHydratedText(fiberRoot, newProps) &&
                      markUpdate(current$$1))
                  : ((newProps = current$$1),
                    (fiberRoot = createTextNode(fiberRoot, type)),
                    precacheFiberNode$1(current$$1, fiberRoot),
                    (newProps.stateNode = fiberRoot)));
            break;
          case 14:
            break;
          case 16:
            break;
          case 10:
            break;
          case 11:
            break;
          case 15:
            break;
          case 4:
            popHostContainer(current$$1);
            updateHostContainer(current$$1);
            break;
          case 13:
            popProvider(current$$1);
            break;
          case 12:
            break;
          case 0:
            reactProdInvariant("167");
          default:
            reactProdInvariant("156");
        }
        current$$1 = nextUnitOfWork = null;
        fiberRoot = workInProgress;
        if (
          1073741823 === nextRenderExpirationTime ||
          1073741823 !== fiberRoot.childExpirationTime
        ) {
          newProps = 0;
          for (type = fiberRoot.child; null !== type; ) {
            current = type.expirationTime;
            oldProps = type.childExpirationTime;
            if (0 === newProps || (0 !== current && current < newProps))
              newProps = current;
            if (0 === newProps || (0 !== oldProps && oldProps < newProps))
              newProps = oldProps;
            type = type.sibling;
          }
          fiberRoot.childExpirationTime = newProps;
        }
        if (null !== current$$1) return current$$1;
        null !== returnFiber &&
          0 === (returnFiber.effectTag & 512) &&
          (null === returnFiber.firstEffect &&
            (returnFiber.firstEffect = workInProgress.firstEffect),
          null !== workInProgress.lastEffect &&
            (null !== returnFiber.lastEffect &&
              (returnFiber.lastEffect.nextEffect = workInProgress.firstEffect),
            (returnFiber.lastEffect = workInProgress.lastEffect)),
          1 < workInProgress.effectTag &&
            (null !== returnFiber.lastEffect
              ? (returnFiber.lastEffect.nextEffect = workInProgress)
              : (returnFiber.firstEffect = workInProgress),
            (returnFiber.lastEffect = workInProgress)));
      } else {
        workInProgress = unwindWork(workInProgress, nextRenderExpirationTime);
        if (null !== workInProgress)
          return (workInProgress.effectTag &= 511), workInProgress;
        null !== returnFiber &&
          ((returnFiber.firstEffect = returnFiber.lastEffect = null),
          (returnFiber.effectTag |= 512));
      }
      if (null !== siblingFiber) return siblingFiber;
      if (null !== returnFiber) workInProgress = returnFiber;
      else break;
    }
    return null;
  }
  function performUnitOfWork(workInProgress) {
    var next = beginWork(
      workInProgress.alternate,
      workInProgress,
      nextRenderExpirationTime
    );
    null === next && (next = completeUnitOfWork(workInProgress));
    ReactCurrentOwner$2.current = null;
    return next;
  }
  function renderRoot(root, isYieldy, isExpired) {
    isWorking ? reactProdInvariant("243") : void 0;
    isWorking = !0;
    ReactCurrentOwner$2.currentDispatcher = Dispatcher;
    var expirationTime = root.nextExpirationTimeToWorkOn;
    if (
      expirationTime !== nextRenderExpirationTime ||
      root !== nextRoot ||
      null === nextUnitOfWork
    )
      resetStack(),
        (nextRoot = root),
        (nextRenderExpirationTime = expirationTime),
        (nextUnitOfWork = createWorkInProgress(
          nextRoot.current,
          null,
          nextRenderExpirationTime
        )),
        (root.pendingCommitExpirationTime = 0);
    var didFatal = !1;
    do {
      try {
        if (isYieldy)
          for (; null !== nextUnitOfWork && !shouldYield(); )
            nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
        else
          for (; null !== nextUnitOfWork; )
            nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
      } catch (thrownValue) {
        if (null === nextUnitOfWork)
          (didFatal = !0), onUncaughtError(thrownValue);
        else {
          null === nextUnitOfWork ? reactProdInvariant("271") : void 0;
          var sourceFiber = nextUnitOfWork,
            returnFiber = sourceFiber.return;
          if (null === returnFiber)
            (didFatal = !0), onUncaughtError(thrownValue);
          else {
            a: {
              var returnFiber$jscomp$0 = returnFiber,
                sourceFiber$jscomp$0 = sourceFiber,
                value = thrownValue;
              returnFiber = nextRenderExpirationTime;
              sourceFiber$jscomp$0.effectTag |= 512;
              sourceFiber$jscomp$0.firstEffect = sourceFiber$jscomp$0.lastEffect = null;
              nextRenderDidError = !0;
              value = createCapturedValue(value, sourceFiber$jscomp$0);
              do {
                switch (returnFiber$jscomp$0.tag) {
                  case 3:
                    returnFiber$jscomp$0.effectTag |= 1024;
                    returnFiber$jscomp$0.expirationTime = returnFiber;
                    returnFiber = createRootErrorUpdate(
                      returnFiber$jscomp$0,
                      value,
                      returnFiber
                    );
                    enqueueCapturedUpdate(returnFiber$jscomp$0, returnFiber);
                    break a;
                  case 2:
                    sourceFiber$jscomp$0 = value;
                    var instance = returnFiber$jscomp$0.stateNode;
                    if (
                      0 === (returnFiber$jscomp$0.effectTag & 64) &&
                      null !== instance &&
                      "function" === typeof instance.componentDidCatch &&
                      (null === legacyErrorBoundariesThatAlreadyFailed ||
                        !legacyErrorBoundariesThatAlreadyFailed.has(instance))
                    ) {
                      returnFiber$jscomp$0.effectTag |= 1024;
                      returnFiber$jscomp$0.expirationTime = returnFiber;
                      returnFiber = createClassErrorUpdate(
                        returnFiber$jscomp$0,
                        sourceFiber$jscomp$0,
                        returnFiber
                      );
                      enqueueCapturedUpdate(returnFiber$jscomp$0, returnFiber);
                      break a;
                    }
                }
                returnFiber$jscomp$0 = returnFiber$jscomp$0.return;
              } while (null !== returnFiber$jscomp$0);
            }
            nextUnitOfWork = completeUnitOfWork(sourceFiber);
            continue;
          }
        }
      }
      break;
    } while (1);
    isWorking = !1;
    lastContext = lastContextDependency = currentlyRenderingFiber = ReactCurrentOwner$2.currentDispatcher = null;
    if (didFatal) (nextRoot = null), (root.finishedWork = null);
    else if (null !== nextUnitOfWork) root.finishedWork = null;
    else {
      isYieldy = root.current.alternate;
      null === isYieldy
        ? invariant(
            !1,
            "Finished root should have a work-in-progress. This error is likely caused by a bug in React. Please file an issue."
          )
        : void 0;
      nextRoot = null;
      if (nextRenderDidError) {
        didFatal = root.latestPendingTime;
        sourceFiber = root.latestSuspendedTime;
        returnFiber = root.latestPingedTime;
        if (
          (0 !== didFatal && didFatal > expirationTime) ||
          (0 !== sourceFiber && sourceFiber > expirationTime) ||
          (0 !== returnFiber && returnFiber > expirationTime)
        ) {
          root.didError = !1;
          isExpired = root.latestPingedTime;
          0 !== isExpired &&
            isExpired <= expirationTime &&
            (root.latestPingedTime = 0);
          isExpired = root.earliestPendingTime;
          isYieldy = root.latestPendingTime;
          isExpired === expirationTime
            ? (root.earliestPendingTime =
                isYieldy === expirationTime
                  ? (root.latestPendingTime = 0)
                  : isYieldy)
            : isYieldy === expirationTime &&
              (root.latestPendingTime = isExpired);
          isExpired = root.earliestSuspendedTime;
          isYieldy = root.latestSuspendedTime;
          0 === isExpired
            ? (root.earliestSuspendedTime = root.latestSuspendedTime = expirationTime)
            : isExpired > expirationTime
              ? (root.earliestSuspendedTime = expirationTime)
              : isYieldy < expirationTime &&
                (root.latestSuspendedTime = expirationTime);
          findNextExpirationTimeToWorkOn(expirationTime, root);
          root.expirationTime = root.expirationTime;
          return;
        }
        if (!root.didError && !isExpired) {
          root.didError = !0;
          root.nextExpirationTimeToWorkOn = expirationTime;
          expirationTime = root.expirationTime = 1;
          root.expirationTime = expirationTime;
          return;
        }
      }
      root.pendingCommitExpirationTime = expirationTime;
      root.finishedWork = isYieldy;
    }
  }
  function captureCommitPhaseError(fiber, error) {
    var JSCompiler_inline_result;
    a: {
      isWorking && !isCommitting$1 ? reactProdInvariant("263") : void 0;
      for (
        JSCompiler_inline_result = fiber.return;
        null !== JSCompiler_inline_result;

      ) {
        switch (JSCompiler_inline_result.tag) {
          case 2:
            var instance = JSCompiler_inline_result.stateNode;
            if (
              "function" ===
                typeof JSCompiler_inline_result.type.getDerivedStateFromCatch ||
              ("function" === typeof instance.componentDidCatch &&
                (null === legacyErrorBoundariesThatAlreadyFailed ||
                  !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
            ) {
              fiber = createCapturedValue(error, fiber);
              fiber = createClassErrorUpdate(
                JSCompiler_inline_result,
                fiber,
                1
              );
              enqueueUpdate(JSCompiler_inline_result, fiber);
              scheduleWork$1(JSCompiler_inline_result, 1);
              JSCompiler_inline_result = void 0;
              break a;
            }
            break;
          case 3:
            fiber = createCapturedValue(error, fiber);
            fiber = createRootErrorUpdate(JSCompiler_inline_result, fiber, 1);
            enqueueUpdate(JSCompiler_inline_result, fiber);
            scheduleWork$1(JSCompiler_inline_result, 1);
            JSCompiler_inline_result = void 0;
            break a;
        }
        JSCompiler_inline_result = JSCompiler_inline_result.return;
      }
      3 === fiber.tag &&
        ((JSCompiler_inline_result = createCapturedValue(error, fiber)),
        (JSCompiler_inline_result = createRootErrorUpdate(
          fiber,
          JSCompiler_inline_result,
          1
        )),
        enqueueUpdate(fiber, JSCompiler_inline_result),
        scheduleWork$1(fiber, 1));
      JSCompiler_inline_result = void 0;
    }
    return JSCompiler_inline_result;
  }
  function computeUniqueAsyncExpiration() {
    var result = 2 + 25 * ((((requestCurrentTime() - 2 + 500) / 25) | 0) + 1);
    result <= lastUniqueAsyncExpiration &&
      (result = lastUniqueAsyncExpiration + 1);
    return (lastUniqueAsyncExpiration = result);
  }
  function computeExpirationForFiber(currentTime, fiber) {
    0 !== expirationContext
      ? (currentTime = expirationContext)
      : isWorking
        ? (currentTime = isCommitting$1 ? 1 : nextRenderExpirationTime)
        : fiber.mode & 1
          ? ((currentTime = isBatchingInteractiveUpdates
              ? 2 + 10 * ((((currentTime - 2 + 15) / 10) | 0) + 1)
              : 2 + 25 * ((((currentTime - 2 + 500) / 25) | 0) + 1)),
            null !== nextRoot &&
              currentTime === nextRenderExpirationTime &&
              (currentTime += 1))
          : (currentTime = 1);
    isBatchingInteractiveUpdates &&
      (0 === lowestPendingInteractiveExpirationTime ||
        currentTime > lowestPendingInteractiveExpirationTime) &&
      (lowestPendingInteractiveExpirationTime = currentTime);
    return currentTime;
  }
  function scheduleWork$1(fiber, expirationTime) {
    a: {
      if (0 === fiber.expirationTime || fiber.expirationTime > expirationTime)
        fiber.expirationTime = expirationTime;
      var alternate = fiber.alternate;
      null !== alternate &&
        (0 === alternate.expirationTime ||
          alternate.expirationTime > expirationTime) &&
        (alternate.expirationTime = expirationTime);
      var node = fiber.return;
      if (null === node && 3 === fiber.tag) fiber = fiber.stateNode;
      else {
        for (; null !== node; ) {
          alternate = node.alternate;
          if (
            0 === node.childExpirationTime ||
            node.childExpirationTime > expirationTime
          )
            node.childExpirationTime = expirationTime;
          null !== alternate &&
            (0 === alternate.childExpirationTime ||
              alternate.childExpirationTime > expirationTime) &&
            (alternate.childExpirationTime = expirationTime);
          if (null === node.return && 3 === node.tag) {
            fiber = node.stateNode;
            break a;
          }
          node = node.return;
        }
        fiber = null;
      }
    }
    null !== fiber &&
      (!isWorking &&
        0 !== nextRenderExpirationTime &&
        expirationTime < nextRenderExpirationTime &&
        resetStack(),
      markPendingPriorityLevel(fiber, expirationTime),
      (isWorking && !isCommitting$1 && nextRoot === fiber) ||
        requestWork(fiber, fiber.expirationTime),
      nestedUpdateCount > NESTED_UPDATE_LIMIT &&
        ((nestedUpdateCount = 0), reactProdInvariant("185")));
  }
  function deferredUpdates(fn) {
    var currentTime = requestCurrentTime(),
      previousExpirationContext = expirationContext;
    expirationContext = 2 + 25 * ((((currentTime - 2 + 500) / 25) | 0) + 1);
    try {
      return fn();
    } finally {
      expirationContext = previousExpirationContext;
    }
  }
  function syncUpdates(fn, a, b, c, d) {
    var previousExpirationContext = expirationContext;
    expirationContext = 1;
    try {
      return fn(a, b, c, d);
    } finally {
      expirationContext = previousExpirationContext;
    }
  }
  function recomputeCurrentRendererTime() {
    currentRendererTime = (((now() - originalStartTimeMs) / 10) | 0) + 2;
  }
  function scheduleCallbackWithExpirationTime(expirationTime) {
    if (0 !== callbackExpirationTime) {
      if (expirationTime > callbackExpirationTime) return;
      null !== callbackID && cancelDeferredCallback(callbackID);
    }
    callbackExpirationTime = expirationTime;
    var currentMs = now() - originalStartTimeMs;
    callbackID = scheduleDeferredCallback(performAsyncWork, {
      timeout: 10 * (expirationTime - 2) - currentMs
    });
  }
  function requestCurrentTime() {
    if (isRendering) return currentSchedulerTime;
    findHighestPriorityRoot();
    if (
      0 === nextFlushedExpirationTime ||
      1073741823 === nextFlushedExpirationTime
    )
      recomputeCurrentRendererTime(),
        (currentSchedulerTime = currentRendererTime);
    return currentSchedulerTime;
  }
  function requestWork(root, expirationTime) {
    if (null === root.nextScheduledRoot)
      (root.expirationTime = expirationTime),
        null === lastScheduledRoot
          ? ((firstScheduledRoot = lastScheduledRoot = root),
            (root.nextScheduledRoot = root))
          : ((lastScheduledRoot = lastScheduledRoot.nextScheduledRoot = root),
            (lastScheduledRoot.nextScheduledRoot = firstScheduledRoot));
    else {
      var remainingExpirationTime = root.expirationTime;
      if (
        0 === remainingExpirationTime ||
        expirationTime < remainingExpirationTime
      )
        root.expirationTime = expirationTime;
    }
    isRendering ||
      (isBatchingUpdates
        ? isUnbatchingUpdates &&
          ((nextFlushedRoot = root),
          (nextFlushedExpirationTime = 1),
          performWorkOnRoot(root, 1, !0))
        : 1 === expirationTime
          ? performWork(1, null)
          : scheduleCallbackWithExpirationTime(expirationTime));
  }
  function findHighestPriorityRoot() {
    var highestPriorityWork = 0,
      highestPriorityRoot = null;
    if (null !== lastScheduledRoot)
      for (
        var previousScheduledRoot = lastScheduledRoot,
          root = firstScheduledRoot;
        null !== root;

      ) {
        var remainingExpirationTime = root.expirationTime;
        if (0 === remainingExpirationTime) {
          null === previousScheduledRoot || null === lastScheduledRoot
            ? reactProdInvariant("244")
            : void 0;
          if (root === root.nextScheduledRoot) {
            firstScheduledRoot = lastScheduledRoot = root.nextScheduledRoot = null;
            break;
          } else if (root === firstScheduledRoot)
            (firstScheduledRoot = remainingExpirationTime =
              root.nextScheduledRoot),
              (lastScheduledRoot.nextScheduledRoot = remainingExpirationTime),
              (root.nextScheduledRoot = null);
          else if (root === lastScheduledRoot) {
            lastScheduledRoot = previousScheduledRoot;
            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
            root.nextScheduledRoot = null;
            break;
          } else
            (previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot),
              (root.nextScheduledRoot = null);
          root = previousScheduledRoot.nextScheduledRoot;
        } else {
          if (
            0 === highestPriorityWork ||
            remainingExpirationTime < highestPriorityWork
          )
            (highestPriorityWork = remainingExpirationTime),
              (highestPriorityRoot = root);
          if (root === lastScheduledRoot) break;
          previousScheduledRoot = root;
          root = root.nextScheduledRoot;
        }
      }
    nextFlushedRoot = highestPriorityRoot;
    nextFlushedExpirationTime = highestPriorityWork;
  }
  function performAsyncWork(dl) {
    performWork(0, dl);
  }
  function performWork(minExpirationTime, dl) {
    deadline = dl;
    findHighestPriorityRoot();
    if (null !== deadline)
      for (
        recomputeCurrentRendererTime(),
          currentSchedulerTime = currentRendererTime;
        null !== nextFlushedRoot &&
        0 !== nextFlushedExpirationTime &&
        (0 === minExpirationTime ||
          minExpirationTime >= nextFlushedExpirationTime) &&
        (!deadlineDidExpire ||
          currentRendererTime >= nextFlushedExpirationTime);

      )
        performWorkOnRoot(
          nextFlushedRoot,
          nextFlushedExpirationTime,
          currentRendererTime >= nextFlushedExpirationTime
        ),
          findHighestPriorityRoot(),
          recomputeCurrentRendererTime(),
          (currentSchedulerTime = currentRendererTime);
    else
      for (
        ;
        null !== nextFlushedRoot &&
        0 !== nextFlushedExpirationTime &&
        (0 === minExpirationTime ||
          minExpirationTime >= nextFlushedExpirationTime);

      )
        performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, !0),
          findHighestPriorityRoot();
    null !== deadline && ((callbackExpirationTime = 0), (callbackID = null));
    0 !== nextFlushedExpirationTime &&
      scheduleCallbackWithExpirationTime(nextFlushedExpirationTime);
    deadline = null;
    deadlineDidExpire = !1;
    nestedUpdateCount = 0;
    lastCommittedRootDuringThisBatch = null;
    if (null !== completedBatches)
      for (
        minExpirationTime = completedBatches, completedBatches = null, dl = 0;
        dl < minExpirationTime.length;
        dl++
      ) {
        var batch = minExpirationTime[dl];
        try {
          batch._onComplete();
        } catch (error) {
          hasUnhandledError ||
            ((hasUnhandledError = !0), (unhandledError = error));
        }
      }
    if (hasUnhandledError)
      throw ((minExpirationTime = unhandledError),
      (unhandledError = null),
      (hasUnhandledError = !1),
      minExpirationTime);
  }
  function flushRoot(root, expirationTime) {
    isRendering ? reactProdInvariant("253") : void 0;
    nextFlushedRoot = root;
    nextFlushedExpirationTime = expirationTime;
    performWorkOnRoot(root, expirationTime, !0);
    performWork(1, null);
  }
  function performWorkOnRoot(root, expirationTime, isExpired) {
    isRendering ? reactProdInvariant("245") : void 0;
    isRendering = !0;
    if (null === deadline || isExpired) {
      var finishedWork = root.finishedWork;
      null !== finishedWork
        ? completeRoot(root, finishedWork, expirationTime)
        : ((root.finishedWork = null),
          renderRoot(root, !1, isExpired),
          (finishedWork = root.finishedWork),
          null !== finishedWork &&
            completeRoot(root, finishedWork, expirationTime));
    } else (finishedWork = root.finishedWork), null !== finishedWork ? completeRoot(root, finishedWork, expirationTime) : ((root.finishedWork = null), renderRoot(root, !0, isExpired), (finishedWork = root.finishedWork), null !== finishedWork && (shouldYield() ? (root.finishedWork = finishedWork) : completeRoot(root, finishedWork, expirationTime)));
    isRendering = !1;
  }
  function completeRoot(root, finishedWork, expirationTime) {
    var firstBatch = root.firstBatch;
    if (
      null !== firstBatch &&
      firstBatch._expirationTime <= expirationTime &&
      (null === completedBatches
        ? (completedBatches = [firstBatch])
        : completedBatches.push(firstBatch),
      firstBatch._defer)
    ) {
      root.finishedWork = finishedWork;
      root.expirationTime = 0;
      return;
    }
    root.finishedWork = null;
    root === lastCommittedRootDuringThisBatch
      ? nestedUpdateCount++
      : ((lastCommittedRootDuringThisBatch = root), (nestedUpdateCount = 0));
    isCommitting$1 = isWorking = !0;
    root.current === finishedWork ? reactProdInvariant("177") : void 0;
    expirationTime = root.pendingCommitExpirationTime;
    0 === expirationTime ? reactProdInvariant("261") : void 0;
    root.pendingCommitExpirationTime = 0;
    firstBatch = finishedWork.expirationTime;
    var childExpirationTimeBeforeCommit = finishedWork.childExpirationTime;
    firstBatch =
      0 === firstBatch ||
      (0 !== childExpirationTimeBeforeCommit &&
        childExpirationTimeBeforeCommit < firstBatch)
        ? childExpirationTimeBeforeCommit
        : firstBatch;
    root.didError = !1;
    0 === firstBatch
      ? ((root.earliestPendingTime = 0),
        (root.latestPendingTime = 0),
        (root.earliestSuspendedTime = 0),
        (root.latestSuspendedTime = 0),
        (root.latestPingedTime = 0))
      : ((childExpirationTimeBeforeCommit = root.latestPendingTime),
        0 !== childExpirationTimeBeforeCommit &&
          (childExpirationTimeBeforeCommit < firstBatch
            ? (root.earliestPendingTime = root.latestPendingTime = 0)
            : root.earliestPendingTime < firstBatch &&
              (root.earliestPendingTime = root.latestPendingTime)),
        (childExpirationTimeBeforeCommit = root.earliestSuspendedTime),
        0 === childExpirationTimeBeforeCommit
          ? markPendingPriorityLevel(root, firstBatch)
          : firstBatch > root.latestSuspendedTime
            ? ((root.earliestSuspendedTime = 0),
              (root.latestSuspendedTime = 0),
              (root.latestPingedTime = 0),
              markPendingPriorityLevel(root, firstBatch))
            : firstBatch < childExpirationTimeBeforeCommit &&
              markPendingPriorityLevel(root, firstBatch));
    findNextExpirationTimeToWorkOn(0, root);
    ReactCurrentOwner$2.current = null;
    1 < finishedWork.effectTag
      ? null !== finishedWork.lastEffect
        ? ((finishedWork.lastEffect.nextEffect = finishedWork),
          (firstBatch = finishedWork.firstEffect))
        : (firstBatch = finishedWork)
      : (firstBatch = finishedWork.firstEffect);
    eventsEnabled = _enabled;
    childExpirationTimeBeforeCommit = getActiveElement();
    if (hasSelectionCapabilities(childExpirationTimeBeforeCommit)) {
      if ("selectionStart" in childExpirationTimeBeforeCommit)
        var JSCompiler_temp = {
          start: childExpirationTimeBeforeCommit.selectionStart,
          end: childExpirationTimeBeforeCommit.selectionEnd
        };
      else
        a: {
          var selection = window.getSelection && window.getSelection();
          if (selection && 0 !== selection.rangeCount) {
            JSCompiler_temp = selection.anchorNode;
            var anchorOffset = selection.anchorOffset,
              focusNode = selection.focusNode;
            selection = selection.focusOffset;
            try {
              JSCompiler_temp.nodeType, focusNode.nodeType;
            } catch (e) {
              JSCompiler_temp = null;
              break a;
            }
            var length = 0,
              start = -1,
              end = -1,
              indexWithinAnchor = 0,
              indexWithinFocus = 0,
              node = childExpirationTimeBeforeCommit,
              parentNode = null;
            b: for (;;) {
              for (var next; ; ) {
                node !== JSCompiler_temp ||
                  (0 !== anchorOffset && 3 !== node.nodeType) ||
                  (start = length + anchorOffset);
                node !== focusNode ||
                  (0 !== selection && 3 !== node.nodeType) ||
                  (end = length + selection);
                3 === node.nodeType && (length += node.nodeValue.length);
                if (null === (next = node.firstChild)) break;
                parentNode = node;
                node = next;
              }
              for (;;) {
                if (node === childExpirationTimeBeforeCommit) break b;
                parentNode === JSCompiler_temp &&
                  ++indexWithinAnchor === anchorOffset &&
                  (start = length);
                parentNode === focusNode &&
                  ++indexWithinFocus === selection &&
                  (end = length);
                if (null !== (next = node.nextSibling)) break;
                node = parentNode;
                parentNode = node.parentNode;
              }
              node = next;
            }
            JSCompiler_temp =
              -1 === start || -1 === end ? null : { start: start, end: end };
          } else JSCompiler_temp = null;
        }
      JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
    } else JSCompiler_temp = null;
    selectionInformation = {
      focusedElem: childExpirationTimeBeforeCommit,
      selectionRange: JSCompiler_temp
    };
    setEnabled(!1);
    for (nextEffect = firstBatch; null !== nextEffect; ) {
      childExpirationTimeBeforeCommit = !1;
      JSCompiler_temp = void 0;
      try {
        for (; null !== nextEffect; ) {
          if (nextEffect.effectTag & 256) {
            var current$$1 = nextEffect.alternate;
            anchorOffset = nextEffect;
            switch (anchorOffset.tag) {
              case 2:
                if (anchorOffset.effectTag & 256 && null !== current$$1) {
                  var prevProps = current$$1.memoizedProps,
                    prevState = current$$1.memoizedState,
                    instance = anchorOffset.stateNode;
                  instance.props = anchorOffset.memoizedProps;
                  instance.state = anchorOffset.memoizedState;
                  var snapshot = instance.getSnapshotBeforeUpdate(
                    prevProps,
                    prevState
                  );
                  instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                }
                break;
              case 3:
              case 5:
              case 6:
              case 4:
                break;
              default:
                reactProdInvariant("163");
            }
          }
          nextEffect = nextEffect.nextEffect;
        }
      } catch (e) {
        (childExpirationTimeBeforeCommit = !0), (JSCompiler_temp = e);
      }
      childExpirationTimeBeforeCommit &&
        (null === nextEffect ? reactProdInvariant("178") : void 0,
        captureCommitPhaseError(nextEffect, JSCompiler_temp),
        null !== nextEffect && (nextEffect = nextEffect.nextEffect));
    }
    for (nextEffect = firstBatch; null !== nextEffect; ) {
      current$$1 = !1;
      prevProps = void 0;
      try {
        for (; null !== nextEffect; ) {
          var effectTag = nextEffect.effectTag;
          effectTag & 16 && setTextContent(nextEffect.stateNode, "");
          if (effectTag & 128) {
            var current$$1$jscomp$0 = nextEffect.alternate;
            if (null !== current$$1$jscomp$0) {
              var currentRef = current$$1$jscomp$0.ref;
              null !== currentRef &&
                ("function" === typeof currentRef
                  ? currentRef(null)
                  : (currentRef.current = null));
            }
          }
          switch (effectTag & 14) {
            case 2:
              commitPlacement(nextEffect);
              nextEffect.effectTag &= -3;
              break;
            case 6:
              commitPlacement(nextEffect);
              nextEffect.effectTag &= -3;
              commitWork(nextEffect.alternate, nextEffect);
              break;
            case 4:
              commitWork(nextEffect.alternate, nextEffect);
              break;
            case 8:
              (prevState = nextEffect),
                unmountHostComponents(prevState),
                (prevState.return = null),
                (prevState.child = null),
                prevState.alternate &&
                  ((prevState.alternate.child = null),
                  (prevState.alternate.return = null));
          }
          nextEffect = nextEffect.nextEffect;
        }
      } catch (e) {
        (current$$1 = !0), (prevProps = e);
      }
      current$$1 &&
        (null === nextEffect ? reactProdInvariant("178") : void 0,
        captureCommitPhaseError(nextEffect, prevProps),
        null !== nextEffect && (nextEffect = nextEffect.nextEffect));
    }
    currentRef = selectionInformation;
    current$$1$jscomp$0 = getActiveElement();
    effectTag = currentRef.focusedElem;
    current$$1 = currentRef.selectionRange;
    if (
      current$$1$jscomp$0 !== effectTag &&
      containsNode(document.documentElement, effectTag)
    ) {
      null !== current$$1 &&
        hasSelectionCapabilities(effectTag) &&
        ((current$$1$jscomp$0 = current$$1.start),
        (currentRef = current$$1.end),
        void 0 === currentRef && (currentRef = current$$1$jscomp$0),
        "selectionStart" in effectTag
          ? ((effectTag.selectionStart = current$$1$jscomp$0),
            (effectTag.selectionEnd = Math.min(
              currentRef,
              effectTag.value.length
            )))
          : window.getSelection &&
            ((current$$1$jscomp$0 = window.getSelection()),
            (prevProps = effectTag[getTextContentAccessor()].length),
            (currentRef = Math.min(current$$1.start, prevProps)),
            (current$$1 =
              void 0 === current$$1.end
                ? currentRef
                : Math.min(current$$1.end, prevProps)),
            !current$$1$jscomp$0.extend &&
              currentRef > current$$1 &&
              ((prevProps = current$$1),
              (current$$1 = currentRef),
              (currentRef = prevProps)),
            (prevProps = getNodeForCharacterOffset(effectTag, currentRef)),
            (prevState = getNodeForCharacterOffset(effectTag, current$$1)),
            prevProps &&
              prevState &&
              (1 !== current$$1$jscomp$0.rangeCount ||
                current$$1$jscomp$0.anchorNode !== prevProps.node ||
                current$$1$jscomp$0.anchorOffset !== prevProps.offset ||
                current$$1$jscomp$0.focusNode !== prevState.node ||
                current$$1$jscomp$0.focusOffset !== prevState.offset) &&
              ((instance = document.createRange()),
              instance.setStart(prevProps.node, prevProps.offset),
              current$$1$jscomp$0.removeAllRanges(),
              currentRef > current$$1
                ? (current$$1$jscomp$0.addRange(instance),
                  current$$1$jscomp$0.extend(prevState.node, prevState.offset))
                : (instance.setEnd(prevState.node, prevState.offset),
                  current$$1$jscomp$0.addRange(instance)))));
      current$$1$jscomp$0 = [];
      for (currentRef = effectTag; (currentRef = currentRef.parentNode); )
        1 === currentRef.nodeType &&
          current$$1$jscomp$0.push({
            element: currentRef,
            left: currentRef.scrollLeft,
            top: currentRef.scrollTop
          });
      "function" === typeof effectTag.focus && effectTag.focus();
      for (effectTag = 0; effectTag < current$$1$jscomp$0.length; effectTag++)
        (currentRef = current$$1$jscomp$0[effectTag]),
          (currentRef.element.scrollLeft = currentRef.left),
          (currentRef.element.scrollTop = currentRef.top);
    }
    selectionInformation = null;
    setEnabled(eventsEnabled);
    eventsEnabled = null;
    root.current = finishedWork;
    for (nextEffect = firstBatch; null !== nextEffect; ) {
      firstBatch = !1;
      effectTag = void 0;
      try {
        for (current$$1$jscomp$0 = expirationTime; null !== nextEffect; ) {
          var effectTag$jscomp$0 = nextEffect.effectTag;
          if (effectTag$jscomp$0 & 36) {
            var current$$1$jscomp$1 = nextEffect.alternate;
            currentRef = nextEffect;
            current$$1 = current$$1$jscomp$0;
            switch (currentRef.tag) {
              case 2:
                var instance$jscomp$0 = currentRef.stateNode;
                if (currentRef.effectTag & 4)
                  if (null === current$$1$jscomp$1)
                    (instance$jscomp$0.props = currentRef.memoizedProps),
                      (instance$jscomp$0.state = currentRef.memoizedState),
                      instance$jscomp$0.componentDidMount();
                  else {
                    var prevProps$jscomp$0 = current$$1$jscomp$1.memoizedProps,
                      prevState$jscomp$0 = current$$1$jscomp$1.memoizedState;
                    instance$jscomp$0.props = currentRef.memoizedProps;
                    instance$jscomp$0.state = currentRef.memoizedState;
                    instance$jscomp$0.componentDidUpdate(
                      prevProps$jscomp$0,
                      prevState$jscomp$0,
                      instance$jscomp$0.__reactInternalSnapshotBeforeUpdate
                    );
                  }
                var updateQueue = currentRef.updateQueue;
                null !== updateQueue &&
                  ((instance$jscomp$0.props = currentRef.memoizedProps),
                  (instance$jscomp$0.state = currentRef.memoizedState),
                  commitUpdateQueue(
                    currentRef,
                    updateQueue,
                    instance$jscomp$0,
                    current$$1
                  ));
                break;
              case 3:
                var _updateQueue = currentRef.updateQueue;
                if (null !== _updateQueue) {
                  prevProps = null;
                  if (null !== currentRef.child)
                    switch (currentRef.child.tag) {
                      case 5:
                        prevProps = currentRef.child.stateNode;
                        break;
                      case 2:
                        prevProps = currentRef.child.stateNode;
                    }
                  commitUpdateQueue(
                    currentRef,
                    _updateQueue,
                    prevProps,
                    current$$1
                  );
                }
                break;
              case 5:
                var _instance2 = currentRef.stateNode;
                null === current$$1$jscomp$1 &&
                  currentRef.effectTag & 4 &&
                  shouldAutoFocusHostComponent(
                    currentRef.type,
                    currentRef.memoizedProps
                  ) &&
                  _instance2.focus();
                break;
              case 6:
                break;
              case 4:
                break;
              case 15:
                break;
              case 16:
                break;
              default:
                reactProdInvariant("163");
            }
          }
          if (effectTag$jscomp$0 & 128) {
            currentRef = void 0;
            var ref = nextEffect.ref;
            if (null !== ref) {
              var instance$jscomp$1 = nextEffect.stateNode;
              switch (nextEffect.tag) {
                case 5:
                  currentRef = instance$jscomp$1;
                  break;
                default:
                  currentRef = instance$jscomp$1;
              }
              "function" === typeof ref
                ? ref(currentRef)
                : (ref.current = currentRef);
            }
          }
          var next$jscomp$0 = nextEffect.nextEffect;
          nextEffect.nextEffect = null;
          nextEffect = next$jscomp$0;
        }
      } catch (e) {
        (firstBatch = !0), (effectTag = e);
      }
      firstBatch &&
        (null === nextEffect ? reactProdInvariant("178") : void 0,
        captureCommitPhaseError(nextEffect, effectTag),
        null !== nextEffect && (nextEffect = nextEffect.nextEffect));
    }
    isWorking = isCommitting$1 = !1;
    "function" === typeof onCommitFiberRoot &&
      onCommitFiberRoot(finishedWork.stateNode);
    effectTag$jscomp$0 = finishedWork.expirationTime;
    finishedWork = finishedWork.childExpirationTime;
    finishedWork =
      0 === effectTag$jscomp$0 ||
      (0 !== finishedWork && finishedWork < effectTag$jscomp$0)
        ? finishedWork
        : effectTag$jscomp$0;
    0 === finishedWork && (legacyErrorBoundariesThatAlreadyFailed = null);
    root.expirationTime = finishedWork;
    root.finishedWork = null;
  }
  function shouldYield() {
    return deadlineDidExpire
      ? !0
      : null === deadline ||
        deadline.timeRemaining() > timeHeuristicForUnitOfWork
        ? !1
        : (deadlineDidExpire = !0);
  }
  function onUncaughtError(error) {
    null === nextFlushedRoot ? reactProdInvariant("246") : void 0;
    nextFlushedRoot.expirationTime = 0;
    hasUnhandledError || ((hasUnhandledError = !0), (unhandledError = error));
  }
  function batchedUpdates$1(fn, a) {
    var previousIsBatchingUpdates = isBatchingUpdates;
    isBatchingUpdates = !0;
    try {
      return fn(a);
    } finally {
      (isBatchingUpdates = previousIsBatchingUpdates) ||
        isRendering ||
        performWork(1, null);
    }
  }
  function unbatchedUpdates(fn, a) {
    if (isBatchingUpdates && !isUnbatchingUpdates) {
      isUnbatchingUpdates = !0;
      try {
        return fn(a);
      } finally {
        isUnbatchingUpdates = !1;
      }
    }
    return fn(a);
  }
  function flushSync(fn, a) {
    isRendering ? reactProdInvariant("187") : void 0;
    var previousIsBatchingUpdates = isBatchingUpdates;
    isBatchingUpdates = !0;
    try {
      return syncUpdates(fn, a);
    } finally {
      (isBatchingUpdates = previousIsBatchingUpdates), performWork(1, null);
    }
  }
  function interactiveUpdates$1(fn, a, b) {
    if (isBatchingInteractiveUpdates) return fn(a, b);
    isBatchingUpdates ||
      isRendering ||
      0 === lowestPendingInteractiveExpirationTime ||
      (performWork(lowestPendingInteractiveExpirationTime, null),
      (lowestPendingInteractiveExpirationTime = 0));
    var previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates,
      previousIsBatchingUpdates = isBatchingUpdates;
    isBatchingUpdates = isBatchingInteractiveUpdates = !0;
    try {
      return fn(a, b);
    } finally {
      (isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates),
        (isBatchingUpdates = previousIsBatchingUpdates) ||
          isRendering ||
          performWork(1, null);
    }
  }
  function flushControlled(fn) {
    var previousIsBatchingUpdates = isBatchingUpdates;
    isBatchingUpdates = !0;
    try {
      syncUpdates(fn);
    } finally {
      (isBatchingUpdates = previousIsBatchingUpdates) ||
        isRendering ||
        performWork(1, null);
    }
  }
  function updateContainerAtExpirationTime(
    element,
    container,
    parentComponent,
    expirationTime,
    callback
  ) {
    var current$$1 = container.current;
    if (parentComponent) {
      parentComponent = parentComponent._reactInternalFiber;
      var parentContext;
      b: {
        2 === isFiberMountedImpl(parentComponent) && 2 === parentComponent.tag
          ? void 0
          : reactProdInvariant("170");
        for (parentContext = parentComponent; 3 !== parentContext.tag; ) {
          if (isContextProvider(parentContext)) {
            parentContext =
              parentContext.stateNode.__reactInternalMemoizedMergedChildContext;
            break b;
          }
          (parentContext = parentContext.return)
            ? void 0
            : reactProdInvariant("171");
        }
        parentContext = parentContext.stateNode.context;
      }
      parentComponent = isContextProvider(parentComponent)
        ? processChildContext(parentComponent, parentContext)
        : parentContext;
    } else parentComponent = emptyContextObject;
    null === container.context
      ? (container.context = parentComponent)
      : (container.pendingContext = parentComponent);
    container = callback;
    callback = createUpdate(expirationTime);
    callback.payload = { element: element };
    container = void 0 === container ? null : container;
    null !== container && (callback.callback = container);
    enqueueUpdate(current$$1, callback);
    scheduleWork$1(current$$1, expirationTime);
    return expirationTime;
  }
  function findHostInstance(component) {
    var fiber = component._reactInternalFiber;
    void 0 === fiber &&
      ("function" === typeof component.render
        ? reactProdInvariant("188")
        : reactProdInvariant("268", Object.keys(component)));
    component = findCurrentHostFiber(fiber);
    return null === component ? null : component.stateNode;
  }
  function updateContainer(element, container, parentComponent, callback) {
    var current$$1 = container.current,
      currentTime = requestCurrentTime();
    current$$1 = computeExpirationForFiber(currentTime, current$$1);
    return updateContainerAtExpirationTime(
      element,
      container,
      parentComponent,
      current$$1,
      callback
    );
  }
  function getPublicRootInstance(container) {
    container = container.current;
    if (!container.child) return null;
    switch (container.child.tag) {
      case 5:
        return container.child.stateNode;
      default:
        return container.child.stateNode;
    }
  }
  function injectIntoDevTools(devToolsConfig) {
    var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
    return injectInternals(
      _assign({}, devToolsConfig, {
        findHostInstanceByFiber: function(fiber) {
          fiber = findCurrentHostFiber(fiber);
          return null === fiber ? null : fiber.stateNode;
        },
        findFiberByHostInstance: function(instance) {
          return findFiberByHostInstance
            ? findFiberByHostInstance(instance)
            : null;
        }
      })
    );
  }
  function createPortal$1(children, containerInfo, implementation) {
    var key =
      3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return {
      $$typeof: REACT_PORTAL_TYPE,
      key: null == key ? null : "" + key,
      children: children,
      containerInfo: containerInfo,
      implementation: implementation
    };
  }
  function ReactBatch(root) {
    this._expirationTime = computeUniqueAsyncExpiration();
    this._root = root;
    this._callbacks = this._next = null;
    this._hasChildren = this._didComplete = !1;
    this._children = null;
    this._defer = !0;
  }
  function ReactWork() {
    this._callbacks = null;
    this._didCommit = !1;
    this._onCommit = this._onCommit.bind(this);
  }
  function ReactRoot(container, isAsync, hydrate) {
    this._internalRoot = createFiberRoot(container, isAsync, hydrate);
  }
  function isValidContainer(node) {
    return !(
      !node ||
      (1 !== node.nodeType &&
        9 !== node.nodeType &&
        11 !== node.nodeType &&
        (8 !== node.nodeType ||
          " react-mount-point-unstable " !== node.nodeValue))
    );
  }
  function legacyCreateRootFromDOMContainer(container, forceHydrate) {
    forceHydrate ||
      ((forceHydrate = container
        ? 9 === container.nodeType
          ? container.documentElement
          : container.firstChild
        : null),
      (forceHydrate = !(
        !forceHydrate ||
        1 !== forceHydrate.nodeType ||
        !forceHydrate.hasAttribute("data-reactroot")
      )));
    if (!forceHydrate)
      for (var rootSibling; (rootSibling = container.lastChild); )
        container.removeChild(rootSibling);
    return new ReactRoot(container, !1, forceHydrate);
  }
  function legacyRenderSubtreeIntoContainer(
    parentComponent,
    children,
    container,
    forceHydrate,
    callback
  ) {
    isValidContainer(container) ? void 0 : reactProdInvariant("200");
    var root = container._reactRootContainer;
    if (root) {
      if ("function" === typeof callback) {
        var _originalCallback = callback;
        callback = function() {
          var instance = getPublicRootInstance(root._internalRoot);
          _originalCallback.call(instance);
        };
      }
      null != parentComponent
        ? root.legacy_renderSubtreeIntoContainer(
            parentComponent,
            children,
            callback
          )
        : root.render(children, callback);
    } else {
      root = container._reactRootContainer = legacyCreateRootFromDOMContainer(
        container,
        forceHydrate
      );
      if ("function" === typeof callback) {
        var originalCallback = callback;
        callback = function() {
          var instance = getPublicRootInstance(root._internalRoot);
          originalCallback.call(instance);
        };
      }
      unbatchedUpdates(function() {
        null != parentComponent
          ? root.legacy_renderSubtreeIntoContainer(
              parentComponent,
              children,
              callback
            )
          : root.render(children, callback);
      });
    }
    return getPublicRootInstance(root._internalRoot);
  }
  function createPortal(children, container) {
    var key =
      2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    isValidContainer(container) ? void 0 : reactProdInvariant("200");
    return createPortal$1(children, container, null, key);
  }
  React ? void 0 : reactProdInvariant("227");
  var invokeGuardedCallback = function(name, func, context, a, b, c, d, e, f) {
      this._hasCaughtError = !1;
      this._caughtError = null;
      var funcArgs = Array.prototype.slice.call(arguments, 3);
      try {
        func.apply(context, funcArgs);
      } catch (error) {
        (this._caughtError = error), (this._hasCaughtError = !0);
      }
    },
    ReactErrorUtils = {
      _caughtError: null,
      _hasCaughtError: !1,
      _rethrowError: null,
      _hasRethrowError: !1,
      invokeGuardedCallback: function(name, func, context, a, b, c, d, e, f) {
        invokeGuardedCallback.apply(ReactErrorUtils, arguments);
      },
      invokeGuardedCallbackAndCatchFirstError: function(
        name,
        func,
        context,
        a,
        b,
        c,
        d,
        e,
        f
      ) {
        ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);
        if (ReactErrorUtils.hasCaughtError()) {
          var error = ReactErrorUtils.clearCaughtError();
          ReactErrorUtils._hasRethrowError ||
            ((ReactErrorUtils._hasRethrowError = !0),
            (ReactErrorUtils._rethrowError = error));
        }
      },
      rethrowCaughtError: function() {
        return rethrowCaughtError.apply(ReactErrorUtils, arguments);
      },
      hasCaughtError: function() {
        return ReactErrorUtils._hasCaughtError;
      },
      clearCaughtError: function() {
        if (ReactErrorUtils._hasCaughtError) {
          var error = ReactErrorUtils._caughtError;
          ReactErrorUtils._caughtError = null;
          ReactErrorUtils._hasCaughtError = !1;
          return error;
        }
        reactProdInvariant("198");
      }
    },
    rethrowCaughtError = function() {
      if (ReactErrorUtils._hasRethrowError) {
        var error = ReactErrorUtils._rethrowError;
        ReactErrorUtils._rethrowError = null;
        ReactErrorUtils._hasRethrowError = !1;
        throw error;
      }
    },
    eventPluginOrder = null,
    namesToPlugins = {},
    plugins = [],
    eventNameDispatchConfigs = {},
    registrationNameModules = {},
    registrationNameDependencies = {},
    EventPluginRegistry = {
      plugins: plugins,
      eventNameDispatchConfigs: eventNameDispatchConfigs,
      registrationNameModules: registrationNameModules,
      registrationNameDependencies: registrationNameDependencies,
      possibleRegistrationNames: null,
      injectEventPluginOrder: injectEventPluginOrder,
      injectEventPluginsByName: injectEventPluginsByName
    },
    getFiberCurrentPropsFromNode = null,
    getInstanceFromNode = null,
    getNodeFromInstance = null,
    eventQueue = null,
    executeDispatchesAndRelease = function(event, simulated) {
      if (event) {
        var dispatchListeners = event._dispatchListeners,
          dispatchInstances = event._dispatchInstances;
        if (Array.isArray(dispatchListeners))
          for (
            var i = 0;
            i < dispatchListeners.length && !event.isPropagationStopped();
            i++
          )
            executeDispatch(
              event,
              simulated,
              dispatchListeners[i],
              dispatchInstances[i]
            );
        else
          dispatchListeners &&
            executeDispatch(
              event,
              simulated,
              dispatchListeners,
              dispatchInstances
            );
        event._dispatchListeners = null;
        event._dispatchInstances = null;
        event.isPersistent() || event.constructor.release(event);
      }
    },
    executeDispatchesAndReleaseSimulated = function(e) {
      return executeDispatchesAndRelease(e, !0);
    },
    executeDispatchesAndReleaseTopLevel = function(e) {
      return executeDispatchesAndRelease(e, !1);
    },
    injection = {
      injectEventPluginOrder: injectEventPluginOrder,
      injectEventPluginsByName: injectEventPluginsByName
    },
    EventPluginHub = {
      injection: injection,
      getListener: getListener,
      runEventsInBatch: runEventsInBatch,
      runExtractedEventsInBatch: runExtractedEventsInBatch
    },
    randomKey = Math.random()
      .toString(36)
      .slice(2),
    internalInstanceKey = "__reactInternalInstance$" + randomKey,
    internalEventHandlersKey = "__reactEventHandlers$" + randomKey,
    ReactDOMComponentTree = {
      precacheFiberNode: precacheFiberNode,
      getClosestInstanceFromNode: getClosestInstanceFromNode,
      getInstanceFromNode: function(node) {
        node = node[internalInstanceKey];
        return !node || (5 !== node.tag && 6 !== node.tag) ? null : node;
      },
      getNodeFromInstance: getNodeFromInstance$1,
      getFiberCurrentPropsFromNode: getFiberCurrentPropsFromNode$1,
      updateFiberProps: updateFiberProps
    },
    EventPropagators = {
      accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
      accumulateTwoPhaseDispatchesSkipTarget: function(events) {
        forEachAccumulated(
          events,
          accumulateTwoPhaseDispatchesSingleSkipTarget
        );
      },
      accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches,
      accumulateDirectDispatches: function(events) {
        forEachAccumulated(events, accumulateDirectDispatchesSingle);
      }
    },
    canUseDOM = !(
      "undefined" === typeof window ||
      !window.document ||
      !window.document.createElement
    ),
    vendorPrefixes = {
      animationend: makePrefixMap("Animation", "AnimationEnd"),
      animationiteration: makePrefixMap("Animation", "AnimationIteration"),
      animationstart: makePrefixMap("Animation", "AnimationStart"),
      transitionend: makePrefixMap("Transition", "TransitionEnd")
    },
    prefixedEventNames = {},
    style = {};
  canUseDOM &&
    ((style = document.createElement("div").style),
    "AnimationEvent" in window ||
      (delete vendorPrefixes.animationend.animation,
      delete vendorPrefixes.animationiteration.animation,
      delete vendorPrefixes.animationstart.animation),
    "TransitionEvent" in window ||
      delete vendorPrefixes.transitionend.transition);
  var TOP_ANIMATION_END = getVendorPrefixedEventName("animationend"),
    TOP_ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"),
    TOP_ANIMATION_START = getVendorPrefixedEventName("animationstart"),
    TOP_TRANSITION_END = getVendorPrefixedEventName("transitionend"),
    mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
    contentKey = null,
    compositionState = { _root: null, _startText: null, _fallbackText: null },
    _assign = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign;
  _assign(SyntheticEvent.prototype, {
    preventDefault: function() {
      this.defaultPrevented = !0;
      var event = this.nativeEvent;
      event &&
        (event.preventDefault
          ? event.preventDefault()
          : "unknown" !== typeof event.returnValue && (event.returnValue = !1),
        (this.isDefaultPrevented = functionThatReturnsTrue));
    },
    stopPropagation: function() {
      var event = this.nativeEvent;
      event &&
        (event.stopPropagation
          ? event.stopPropagation()
          : "unknown" !== typeof event.cancelBubble &&
            (event.cancelBubble = !0),
        (this.isPropagationStopped = functionThatReturnsTrue));
    },
    persist: function() {
      this.isPersistent = functionThatReturnsTrue;
    },
    isPersistent: functionThatReturnsFalse,
    destructor: function() {
      var Interface = this.constructor.Interface,
        propName;
      for (propName in Interface) this[propName] = null;
      this.nativeEvent = this._targetInst = this.dispatchConfig = null;
      this.isPropagationStopped = this.isDefaultPrevented = functionThatReturnsFalse;
      this._dispatchInstances = this._dispatchListeners = null;
    }
  });
  SyntheticEvent.Interface = {
    type: null,
    target: null,
    currentTarget: function() {
      return null;
    },
    eventPhase: null,
    bubbles: null,
    cancelable: null,
    timeStamp: function(event) {
      return event.timeStamp || Date.now();
    },
    defaultPrevented: null,
    isTrusted: null
  };
  addEventPoolingTo(SyntheticEvent);
  var classCallCheck = function(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    },
    inherits = function(subClass, superClass) {
      if ("function" !== typeof superClass && null !== superClass)
        throw new TypeError(
          "Super expression must either be null or a function, not " +
            typeof superClass
        );
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      });
      superClass &&
        (Object.setPrototypeOf
          ? Object.setPrototypeOf(subClass, superClass)
          : (subClass.__proto__ = superClass));
    },
    possibleConstructorReturn = function(self, call) {
      if (!self)
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      return !call || ("object" !== typeof call && "function" !== typeof call)
        ? self
        : call;
    },
    SyntheticCompositionEvent = (function(_SyntheticEvent) {
      function SyntheticCompositionEvent() {
        classCallCheck(this, SyntheticCompositionEvent);
        return possibleConstructorReturn(
          this,
          _SyntheticEvent.apply(this, arguments)
        );
      }
      inherits(SyntheticCompositionEvent, _SyntheticEvent);
      return SyntheticCompositionEvent;
    })(SyntheticEvent);
  extend(SyntheticCompositionEvent, { data: null });
  var SyntheticInputEvent = (function(_SyntheticEvent) {
    function SyntheticInputEvent() {
      classCallCheck(this, SyntheticInputEvent);
      return possibleConstructorReturn(
        this,
        _SyntheticEvent.apply(this, arguments)
      );
    }
    inherits(SyntheticInputEvent, _SyntheticEvent);
    return SyntheticInputEvent;
  })(SyntheticEvent);
  extend(SyntheticInputEvent, { data: null });
  var END_KEYCODES = [9, 13, 27, 32],
    canUseCompositionEvent = canUseDOM && "CompositionEvent" in window,
    documentMode = null;
  canUseDOM &&
    "documentMode" in document &&
    (documentMode = document.documentMode);
  var canUseTextInputEvent =
      canUseDOM && "TextEvent" in window && !documentMode,
    useFallbackCompositionData =
      canUseDOM &&
      (!canUseCompositionEvent ||
        (documentMode && 8 < documentMode && 11 >= documentMode)),
    SPACEBAR_CHAR = String.fromCharCode(32),
    eventTypes = {
      beforeInput: {
        phasedRegistrationNames: {
          bubbled: "onBeforeInput",
          captured: "onBeforeInputCapture"
        },
        dependencies: ["compositionend", "keypress", "textInput", "paste"]
      },
      compositionEnd: {
        phasedRegistrationNames: {
          bubbled: "onCompositionEnd",
          captured: "onCompositionEndCapture"
        },
        dependencies: "blur compositionend keydown keypress keyup mousedown".split(
          " "
        )
      },
      compositionStart: {
        phasedRegistrationNames: {
          bubbled: "onCompositionStart",
          captured: "onCompositionStartCapture"
        },
        dependencies: "blur compositionstart keydown keypress keyup mousedown".split(
          " "
        )
      },
      compositionUpdate: {
        phasedRegistrationNames: {
          bubbled: "onCompositionUpdate",
          captured: "onCompositionUpdateCapture"
        },
        dependencies: "blur compositionupdate keydown keypress keyup mousedown".split(
          " "
        )
      }
    },
    hasSpaceKeypress = !1,
    isComposing = !1,
    BeforeInputEventPlugin = {
      eventTypes: eventTypes,
      extractEvents: function(
        topLevelType,
        targetInst,
        nativeEvent,
        nativeEventTarget
      ) {
        var eventType = void 0;
        var composition = void 0;
        if (canUseCompositionEvent)
          b: {
            switch (topLevelType) {
              case "compositionstart":
                eventType = eventTypes.compositionStart;
                break b;
              case "compositionend":
                eventType = eventTypes.compositionEnd;
                break b;
              case "compositionupdate":
                eventType = eventTypes.compositionUpdate;
                break b;
            }
            eventType = void 0;
          }
        else
          isComposing
            ? isFallbackCompositionEnd(topLevelType, nativeEvent) &&
              (eventType = eventTypes.compositionEnd)
            : "keydown" === topLevelType &&
              229 === nativeEvent.keyCode &&
              (eventType = eventTypes.compositionStart);
        eventType
          ? (useFallbackCompositionData &&
              "ko" !== nativeEvent.locale &&
              (isComposing || eventType !== eventTypes.compositionStart
                ? eventType === eventTypes.compositionEnd &&
                  isComposing &&
                  (composition = getData())
                : ((compositionState._root = nativeEventTarget),
                  (compositionState._startText = getText()),
                  (isComposing = !0))),
            (eventType = SyntheticCompositionEvent.getPooled(
              eventType,
              targetInst,
              nativeEvent,
              nativeEventTarget
            )),
            composition
              ? (eventType.data = composition)
              : ((composition = getDataFromCustomEvent(nativeEvent)),
                null !== composition && (eventType.data = composition)),
            accumulateTwoPhaseDispatches(eventType),
            (composition = eventType))
          : (composition = null);
        (topLevelType = canUseTextInputEvent
          ? getNativeBeforeInputChars(topLevelType, nativeEvent)
          : getFallbackBeforeInputChars(topLevelType, nativeEvent))
          ? ((targetInst = SyntheticInputEvent.getPooled(
              eventTypes.beforeInput,
              targetInst,
              nativeEvent,
              nativeEventTarget
            )),
            (targetInst.data = topLevelType),
            accumulateTwoPhaseDispatches(targetInst))
          : (targetInst = null);
        return null === composition
          ? targetInst
          : null === targetInst
            ? composition
            : [composition, targetInst];
      }
    },
    fiberHostComponent = null,
    restoreTarget = null,
    restoreQueue = null,
    injection$2 = {
      injectFiberControlledHostComponent: function(hostComponentImpl) {
        fiberHostComponent = hostComponentImpl;
      }
    },
    ReactControlledComponent = {
      injection: injection$2,
      enqueueStateRestore: enqueueStateRestore,
      needsStateRestore: needsStateRestore,
      restoreStateIfNeeded: restoreStateIfNeeded
    },
    _batchedUpdates = function(fn, bookkeeping) {
      return fn(bookkeeping);
    },
    _interactiveUpdates = function(fn, a, b) {
      return fn(a, b);
    },
    _flushInteractiveUpdates = function() {},
    isBatching = !1,
    supportedInputTypes = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    },
    ReactSharedInternals =
      React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    hasSymbol = "function" === typeof Symbol && Symbol.for,
    REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103,
    REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106,
    REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107,
    REACT_STRICT_MODE_TYPE = hasSymbol
      ? Symbol.for("react.strict_mode")
      : 60108,
    REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114,
    REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109,
    REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110,
    REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111,
    REACT_FORWARD_REF_TYPE = hasSymbol
      ? Symbol.for("react.forward_ref")
      : 60112,
    REACT_PLACEHOLDER_TYPE = hasSymbol
      ? Symbol.for("react.placeholder")
      : 60113,
    MAYBE_ITERATOR_SYMBOL = "function" === typeof Symbol && Symbol.iterator,
    VALID_ATTRIBUTE_NAME_REGEX = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    illegalAttributeNameCache = {},
    validatedAttributeNameCache = {},
    properties = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
    .split(" ")
    .forEach(function(name) {
      properties[name] = new PropertyInfoRecord(name, 0, !1, name, null);
    });
  [
    ["acceptCharset", "accept-charset"],
    ["className", "class"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"]
  ].forEach(function(_ref) {
    var name = _ref[0];
    properties[name] = new PropertyInfoRecord(name, 1, !1, _ref[1], null);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(
    name
  ) {
    properties[name] = new PropertyInfoRecord(
      name,
      2,
      !1,
      name.toLowerCase(),
      null
    );
  });
  ["autoReverse", "externalResourcesRequired", "preserveAlpha"].forEach(
    function(name) {
      properties[name] = new PropertyInfoRecord(name, 2, !1, name, null);
    }
  );
  "allowFullScreen async autoFocus autoPlay controls default defer disabled formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
    .split(" ")
    .forEach(function(name) {
      properties[name] = new PropertyInfoRecord(
        name,
        3,
        !1,
        name.toLowerCase(),
        null
      );
    });
  ["checked", "multiple", "muted", "selected"].forEach(function(name) {
    properties[name] = new PropertyInfoRecord(
      name,
      3,
      !0,
      name.toLowerCase(),
      null
    );
  });
  ["capture", "download"].forEach(function(name) {
    properties[name] = new PropertyInfoRecord(
      name,
      4,
      !1,
      name.toLowerCase(),
      null
    );
  });
  ["cols", "rows", "size", "span"].forEach(function(name) {
    properties[name] = new PropertyInfoRecord(
      name,
      6,
      !1,
      name.toLowerCase(),
      null
    );
  });
  ["rowSpan", "start"].forEach(function(name) {
    properties[name] = new PropertyInfoRecord(
      name,
      5,
      !1,
      name.toLowerCase(),
      null
    );
  });
  var CAMELIZE = /[\-:]([a-z])/g,
    capitalize = function(token) {
      return token[1].toUpperCase();
    };
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
    .split(" ")
    .forEach(function(attributeName) {
      var name = attributeName.replace(CAMELIZE, capitalize);
      properties[name] = new PropertyInfoRecord(
        name,
        1,
        !1,
        attributeName,
        null
      );
    });
  "xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type"
    .split(" ")
    .forEach(function(attributeName) {
      var name = attributeName.replace(CAMELIZE, capitalize);
      properties[name] = new PropertyInfoRecord(
        name,
        1,
        !1,
        attributeName,
        "http://www.w3.org/1999/xlink"
      );
    });
  ["xml:base", "xml:lang", "xml:space"].forEach(function(attributeName) {
    var name = attributeName.replace(CAMELIZE, capitalize);
    properties[name] = new PropertyInfoRecord(
      name,
      1,
      !1,
      attributeName,
      "http://www.w3.org/XML/1998/namespace"
    );
  });
  properties.tabIndex = new PropertyInfoRecord(
    "tabIndex",
    1,
    !1,
    "tabindex",
    null
  );
  var eventTypes$1 = {
      change: {
        phasedRegistrationNames: {
          bubbled: "onChange",
          captured: "onChangeCapture"
        },
        dependencies: "blur change click focus input keydown keyup selectionchange".split(
          " "
        )
      }
    },
    activeElement = null,
    activeElementInst = null,
    isInputEventSupported = !1;
  canUseDOM &&
    (isInputEventSupported =
      isEventSupported("input") &&
      (!document.documentMode || 9 < document.documentMode));
  var ChangeEventPlugin = {
      eventTypes: eventTypes$1,
      _isInputEventSupported: isInputEventSupported,
      extractEvents: function(
        topLevelType,
        targetInst,
        nativeEvent,
        nativeEventTarget
      ) {
        var targetNode = targetInst
            ? getNodeFromInstance$1(targetInst)
            : window,
          getTargetInstFunc = void 0,
          handleEventFunc = void 0,
          nodeName = targetNode.nodeName && targetNode.nodeName.toLowerCase();
        "select" === nodeName ||
        ("input" === nodeName && "file" === targetNode.type)
          ? (getTargetInstFunc = getTargetInstForChangeEvent)
          : isTextInputElement(targetNode)
            ? isInputEventSupported
              ? (getTargetInstFunc = getTargetInstForInputOrChangeEvent)
              : ((getTargetInstFunc = getTargetInstForInputEventPolyfill),
                (handleEventFunc = handleEventsForInputEventPolyfill))
            : (nodeName = targetNode.nodeName) &&
              "input" === nodeName.toLowerCase() &&
              ("checkbox" === targetNode.type || "radio" === targetNode.type) &&
              (getTargetInstFunc = getTargetInstForClickEvent);
        if (
          getTargetInstFunc &&
          (getTargetInstFunc = getTargetInstFunc(topLevelType, targetInst))
        )
          return createAndAccumulateChangeEvent(
            getTargetInstFunc,
            nativeEvent,
            nativeEventTarget
          );
        handleEventFunc &&
          handleEventFunc(topLevelType, targetNode, targetInst);
        "blur" === topLevelType &&
          (topLevelType = targetNode._wrapperState) &&
          topLevelType.controlled &&
          "number" === targetNode.type &&
          setDefaultValue(targetNode, "number", targetNode.value);
      }
    },
    modifierKeyToProp = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    },
    SyntheticUIEvent = (function(_SyntheticEvent) {
      function SyntheticUIEvent() {
        classCallCheck(this, SyntheticUIEvent);
        return possibleConstructorReturn(
          this,
          _SyntheticEvent.apply(this, arguments)
        );
      }
      inherits(SyntheticUIEvent, _SyntheticEvent);
      return SyntheticUIEvent;
    })(SyntheticEvent);
  extend(SyntheticUIEvent, { view: null, detail: null });
  var previousScreenX = 0,
    previousScreenY = 0,
    isMovementXSet = !1,
    isMovementYSet = !1,
    SyntheticMouseEvent = (function(_SyntheticUIEvent) {
      function SyntheticMouseEvent() {
        classCallCheck(this, SyntheticMouseEvent);
        return possibleConstructorReturn(
          this,
          _SyntheticUIEvent.apply(this, arguments)
        );
      }
      inherits(SyntheticMouseEvent, _SyntheticUIEvent);
      return SyntheticMouseEvent;
    })(SyntheticUIEvent);
  extend(SyntheticMouseEvent, {
    screenX: null,
    screenY: null,
    clientX: null,
    clientY: null,
    pageX: null,
    pageY: null,
    ctrlKey: null,
    shiftKey: null,
    altKey: null,
    metaKey: null,
    getModifierState: getEventModifierState,
    button: null,
    buttons: null,
    relatedTarget: function(event) {
      return (
        event.relatedTarget ||
        (event.fromElement === event.srcElement
          ? event.toElement
          : event.fromElement)
      );
    },
    movementX: function(event) {
      if ("movementX" in event) return event.movementX;
      var screenX = previousScreenX;
      previousScreenX = event.screenX;
      return isMovementXSet
        ? "mousemove" === event.type
          ? event.screenX - screenX
          : 0
        : ((isMovementXSet = !0), 0);
    },
    movementY: function(event) {
      if ("movementY" in event) return event.movementY;
      var screenY = previousScreenY;
      previousScreenY = event.screenY;
      return isMovementYSet
        ? "mousemove" === event.type
          ? event.screenY - screenY
          : 0
        : ((isMovementYSet = !0), 0);
    }
  });
  var SyntheticPointerEvent = (function(_SyntheticMouseEvent) {
    function SyntheticPointerEvent() {
      classCallCheck(this, SyntheticPointerEvent);
      return possibleConstructorReturn(
        this,
        _SyntheticMouseEvent.apply(this, arguments)
      );
    }
    inherits(SyntheticPointerEvent, _SyntheticMouseEvent);
    return SyntheticPointerEvent;
  })(SyntheticMouseEvent);
  extend(SyntheticPointerEvent, {
    pointerId: null,
    width: null,
    height: null,
    pressure: null,
    tiltX: null,
    tiltY: null,
    pointerType: null,
    isPrimary: null
  });
  var eventTypes$2 = {
      mouseEnter: {
        registrationName: "onMouseEnter",
        dependencies: ["mouseout", "mouseover"]
      },
      mouseLeave: {
        registrationName: "onMouseLeave",
        dependencies: ["mouseout", "mouseover"]
      },
      pointerEnter: {
        registrationName: "onPointerEnter",
        dependencies: ["pointerout", "pointerover"]
      },
      pointerLeave: {
        registrationName: "onPointerLeave",
        dependencies: ["pointerout", "pointerover"]
      }
    },
    EnterLeaveEventPlugin = {
      eventTypes: eventTypes$2,
      extractEvents: function(
        topLevelType,
        targetInst,
        nativeEvent,
        nativeEventTarget
      ) {
        var isOverEvent =
            "mouseover" === topLevelType || "pointerover" === topLevelType,
          isOutEvent =
            "mouseout" === topLevelType || "pointerout" === topLevelType;
        if (
          (isOverEvent &&
            (nativeEvent.relatedTarget || nativeEvent.fromElement)) ||
          (!isOutEvent && !isOverEvent)
        )
          return null;
        isOverEvent =
          nativeEventTarget.window === nativeEventTarget
            ? nativeEventTarget
            : (isOverEvent = nativeEventTarget.ownerDocument)
              ? isOverEvent.defaultView || isOverEvent.parentWindow
              : window;
        isOutEvent
          ? ((isOutEvent = targetInst),
            (targetInst = (targetInst =
              nativeEvent.relatedTarget || nativeEvent.toElement)
              ? getClosestInstanceFromNode(targetInst)
              : null))
          : (isOutEvent = null);
        if (isOutEvent === targetInst) return null;
        var eventInterface = void 0,
          leaveEventType = void 0,
          enterEventType = void 0,
          eventTypePrefix = void 0;
        if ("mouseout" === topLevelType || "mouseover" === topLevelType)
          (eventInterface = SyntheticMouseEvent),
            (leaveEventType = eventTypes$2.mouseLeave),
            (enterEventType = eventTypes$2.mouseEnter),
            (eventTypePrefix = "mouse");
        else if (
          "pointerout" === topLevelType ||
          "pointerover" === topLevelType
        )
          (eventInterface = SyntheticPointerEvent),
            (leaveEventType = eventTypes$2.pointerLeave),
            (enterEventType = eventTypes$2.pointerEnter),
            (eventTypePrefix = "pointer");
        topLevelType =
          null == isOutEvent ? isOverEvent : getNodeFromInstance$1(isOutEvent);
        isOverEvent =
          null == targetInst ? isOverEvent : getNodeFromInstance$1(targetInst);
        leaveEventType = eventInterface.getPooled(
          leaveEventType,
          isOutEvent,
          nativeEvent,
          nativeEventTarget
        );
        leaveEventType.type = eventTypePrefix + "leave";
        leaveEventType.target = topLevelType;
        leaveEventType.relatedTarget = isOverEvent;
        nativeEvent = eventInterface.getPooled(
          enterEventType,
          targetInst,
          nativeEvent,
          nativeEventTarget
        );
        nativeEvent.type = eventTypePrefix + "enter";
        nativeEvent.target = isOverEvent;
        nativeEvent.relatedTarget = topLevelType;
        accumulateEnterLeaveDispatches(
          leaveEventType,
          nativeEvent,
          isOutEvent,
          targetInst
        );
        return [leaveEventType, nativeEvent];
      }
    },
    hasOwnProperty = Object.prototype.hasOwnProperty,
    SyntheticAnimationEvent = (function(_SyntheticEvent) {
      function SyntheticAnimationEvent() {
        classCallCheck(this, SyntheticAnimationEvent);
        return possibleConstructorReturn(
          this,
          _SyntheticEvent.apply(this, arguments)
        );
      }
      inherits(SyntheticAnimationEvent, _SyntheticEvent);
      return SyntheticAnimationEvent;
    })(SyntheticEvent);
  extend(SyntheticAnimationEvent, {
    animationName: null,
    elapsedTime: null,
    pseudoElement: null
  });
  var SyntheticClipboardEvent = (function(_SyntheticEvent) {
    function SyntheticClipboardEvent() {
      classCallCheck(this, SyntheticClipboardEvent);
      return possibleConstructorReturn(
        this,
        _SyntheticEvent.apply(this, arguments)
      );
    }
    inherits(SyntheticClipboardEvent, _SyntheticEvent);
    return SyntheticClipboardEvent;
  })(SyntheticEvent);
  extend(SyntheticClipboardEvent, {
    clipboardData: function(event) {
      return "clipboardData" in event
        ? event.clipboardData
        : window.clipboardData;
    }
  });
  var SyntheticFocusEvent = (function(_SyntheticUIEvent) {
    function SyntheticFocusEvent() {
      classCallCheck(this, SyntheticFocusEvent);
      return possibleConstructorReturn(
        this,
        _SyntheticUIEvent.apply(this, arguments)
      );
    }
    inherits(SyntheticFocusEvent, _SyntheticUIEvent);
    return SyntheticFocusEvent;
  })(SyntheticUIEvent);
  extend(SyntheticFocusEvent, { relatedTarget: null });
  var normalizeKey = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    },
    translateToKey = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    },
    SyntheticKeyboardEvent = (function(_SyntheticUIEvent) {
      function SyntheticKeyboardEvent() {
        classCallCheck(this, SyntheticKeyboardEvent);
        return possibleConstructorReturn(
          this,
          _SyntheticUIEvent.apply(this, arguments)
        );
      }
      inherits(SyntheticKeyboardEvent, _SyntheticUIEvent);
      return SyntheticKeyboardEvent;
    })(SyntheticUIEvent);
  extend(SyntheticKeyboardEvent, {
    key: function(nativeEvent) {
      if (nativeEvent.key) {
        var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
        if ("Unidentified" !== key) return key;
      }
      return "keypress" === nativeEvent.type
        ? ((nativeEvent = getEventCharCode(nativeEvent)),
          13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent))
        : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type
          ? translateToKey[nativeEvent.keyCode] || "Unidentified"
          : "";
    },
    location: null,
    ctrlKey: null,
    shiftKey: null,
    altKey: null,
    metaKey: null,
    repeat: null,
    locale: null,
    getModifierState: getEventModifierState,
    charCode: function(event) {
      return "keypress" === event.type ? getEventCharCode(event) : 0;
    },
    keyCode: function(event) {
      return "keydown" === event.type || "keyup" === event.type
        ? event.keyCode
        : 0;
    },
    which: function(event) {
      return "keypress" === event.type
        ? getEventCharCode(event)
        : "keydown" === event.type || "keyup" === event.type
          ? event.keyCode
          : 0;
    }
  });
  var SyntheticDragEvent = (function(_SyntheticMouseEvent) {
    function SyntheticDragEvent() {
      classCallCheck(this, SyntheticDragEvent);
      return possibleConstructorReturn(
        this,
        _SyntheticMouseEvent.apply(this, arguments)
      );
    }
    inherits(SyntheticDragEvent, _SyntheticMouseEvent);
    return SyntheticDragEvent;
  })(SyntheticMouseEvent);
  extend(SyntheticDragEvent, { dataTransfer: null });
  var SyntheticTouchEvent = (function(_SyntheticUIEvent) {
    function SyntheticTouchEvent() {
      classCallCheck(this, SyntheticTouchEvent);
      return possibleConstructorReturn(
        this,
        _SyntheticUIEvent.apply(this, arguments)
      );
    }
    inherits(SyntheticTouchEvent, _SyntheticUIEvent);
    return SyntheticTouchEvent;
  })(SyntheticUIEvent);
  extend(SyntheticTouchEvent, {
    touches: null,
    targetTouches: null,
    changedTouches: null,
    altKey: null,
    metaKey: null,
    ctrlKey: null,
    shiftKey: null,
    getModifierState: getEventModifierState
  });
  var SyntheticTransitionEvent = (function(_SyntheticEvent) {
    function SyntheticTransitionEvent() {
      classCallCheck(this, SyntheticTransitionEvent);
      return possibleConstructorReturn(
        this,
        _SyntheticEvent.apply(this, arguments)
      );
    }
    inherits(SyntheticTransitionEvent, _SyntheticEvent);
    return SyntheticTransitionEvent;
  })(SyntheticEvent);
  extend(SyntheticTransitionEvent, {
    propertyName: null,
    elapsedTime: null,
    pseudoElement: null
  });
  var SyntheticWheelEvent = (function(_SyntheticMouseEvent) {
    function SyntheticWheelEvent() {
      classCallCheck(this, SyntheticWheelEvent);
      return possibleConstructorReturn(
        this,
        _SyntheticMouseEvent.apply(this, arguments)
      );
    }
    inherits(SyntheticWheelEvent, _SyntheticMouseEvent);
    return SyntheticWheelEvent;
  })(SyntheticMouseEvent);
  extend(SyntheticWheelEvent, {
    deltaX: function(event) {
      return "deltaX" in event
        ? event.deltaX
        : "wheelDeltaX" in event
          ? -event.wheelDeltaX
          : 0;
    },
    deltaY: function(event) {
      return "deltaY" in event
        ? event.deltaY
        : "wheelDeltaY" in event
          ? -event.wheelDeltaY
          : "wheelDelta" in event
            ? -event.wheelDelta
            : 0;
    },
    deltaZ: null,
    deltaMode: null
  });
  var nonInteractiveEventTypeNames = [
      ["abort", "abort"],
      [TOP_ANIMATION_END, "animationEnd"],
      [TOP_ANIMATION_ITERATION, "animationIteration"],
      [TOP_ANIMATION_START, "animationStart"],
      ["canplay", "canPlay"],
      ["canplaythrough", "canPlayThrough"],
      ["drag", "drag"],
      ["dragenter", "dragEnter"],
      ["dragexit", "dragExit"],
      ["dragleave", "dragLeave"],
      ["dragover", "dragOver"],
      ["durationchange", "durationChange"],
      ["emptied", "emptied"],
      ["encrypted", "encrypted"],
      ["ended", "ended"],
      ["error", "error"],
      ["gotpointercapture", "gotPointerCapture"],
      ["load", "load"],
      ["loadeddata", "loadedData"],
      ["loadedmetadata", "loadedMetadata"],
      ["loadstart", "loadStart"],
      ["lostpointercapture", "lostPointerCapture"],
      ["mousemove", "mouseMove"],
      ["mouseout", "mouseOut"],
      ["mouseover", "mouseOver"],
      ["playing", "playing"],
      ["pointermove", "pointerMove"],
      ["pointerout", "pointerOut"],
      ["pointerover", "pointerOver"],
      ["progress", "progress"],
      ["scroll", "scroll"],
      ["seeking", "seeking"],
      ["stalled", "stalled"],
      ["suspend", "suspend"],
      ["timeupdate", "timeUpdate"],
      ["toggle", "toggle"],
      ["touchmove", "touchMove"],
      [TOP_TRANSITION_END, "transitionEnd"],
      ["waiting", "waiting"],
      ["wheel", "wheel"]
    ],
    eventTypes$4 = {},
    topLevelEventsToDispatchConfig = {};
  [
    ["blur", "blur"],
    ["cancel", "cancel"],
    ["click", "click"],
    ["close", "close"],
    ["contextmenu", "contextMenu"],
    ["copy", "copy"],
    ["cut", "cut"],
    ["dblclick", "doubleClick"],
    ["dragend", "dragEnd"],
    ["dragstart", "dragStart"],
    ["drop", "drop"],
    ["focus", "focus"],
    ["input", "input"],
    ["invalid", "invalid"],
    ["keydown", "keyDown"],
    ["keypress", "keyPress"],
    ["keyup", "keyUp"],
    ["mousedown", "mouseDown"],
    ["mouseup", "mouseUp"],
    ["paste", "paste"],
    ["pause", "pause"],
    ["play", "play"],
    ["pointercancel", "pointerCancel"],
    ["pointerdown", "pointerDown"],
    ["pointerup", "pointerUp"],
    ["ratechange", "rateChange"],
    ["reset", "reset"],
    ["seeked", "seeked"],
    ["submit", "submit"],
    ["touchcancel", "touchCancel"],
    ["touchend", "touchEnd"],
    ["touchstart", "touchStart"],
    ["volumechange", "volumeChange"]
  ].forEach(function(eventTuple) {
    addEventTypeNameToConfig(eventTuple, !0);
  });
  nonInteractiveEventTypeNames.forEach(function(eventTuple) {
    addEventTypeNameToConfig(eventTuple, !1);
  });
  var SimpleEventPlugin = {
      eventTypes: eventTypes$4,
      isInteractiveTopLevelEventType: function(topLevelType) {
        topLevelType = topLevelEventsToDispatchConfig[topLevelType];
        return void 0 !== topLevelType && !0 === topLevelType.isInteractive;
      },
      extractEvents: function(
        topLevelType,
        targetInst,
        nativeEvent,
        nativeEventTarget
      ) {
        var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
        if (!dispatchConfig) return null;
        switch (topLevelType) {
          case "keypress":
            if (0 === getEventCharCode(nativeEvent)) return null;
          case "keydown":
          case "keyup":
            topLevelType = SyntheticKeyboardEvent;
            break;
          case "blur":
          case "focus":
            topLevelType = SyntheticFocusEvent;
            break;
          case "click":
            if (2 === nativeEvent.button) return null;
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            topLevelType = SyntheticMouseEvent;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            topLevelType = SyntheticDragEvent;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            topLevelType = SyntheticTouchEvent;
            break;
          case TOP_ANIMATION_END:
          case TOP_ANIMATION_ITERATION:
          case TOP_ANIMATION_START:
            topLevelType = SyntheticAnimationEvent;
            break;
          case TOP_TRANSITION_END:
            topLevelType = SyntheticTransitionEvent;
            break;
          case "scroll":
            topLevelType = SyntheticUIEvent;
            break;
          case "wheel":
            topLevelType = SyntheticWheelEvent;
            break;
          case "copy":
          case "cut":
          case "paste":
            topLevelType = SyntheticClipboardEvent;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            topLevelType = SyntheticPointerEvent;
            break;
          default:
            topLevelType = SyntheticEvent;
        }
        targetInst = topLevelType.getPooled(
          dispatchConfig,
          targetInst,
          nativeEvent,
          nativeEventTarget
        );
        accumulateTwoPhaseDispatches(targetInst);
        return targetInst;
      }
    },
    isInteractiveTopLevelEventType =
      SimpleEventPlugin.isInteractiveTopLevelEventType,
    callbackBookkeepingPool = [],
    _enabled = !0,
    ReactDOMEventListener = {
      get _enabled() {
        return _enabled;
      },
      setEnabled: setEnabled,
      isEnabled: function() {
        return _enabled;
      },
      trapBubbledEvent: trapBubbledEvent,
      trapCapturedEvent: trapCapturedEvent,
      dispatchEvent: dispatchEvent
    },
    alreadyListeningTo = {},
    reactTopListenersCounter = 0,
    topListenersIDKey = "_reactListenersID" + ("" + Math.random()).slice(2),
    skipSelectionChangeEvent =
      canUseDOM && "documentMode" in document && 11 >= document.documentMode,
    eventTypes$3 = {
      select: {
        phasedRegistrationNames: {
          bubbled: "onSelect",
          captured: "onSelectCapture"
        },
        dependencies: "blur contextmenu focus keydown keyup mousedown mouseup selectionchange".split(
          " "
        )
      }
    },
    activeElement$1 = null,
    activeElementInst$1 = null,
    lastSelection = null,
    mouseDown = !1,
    SelectEventPlugin = {
      eventTypes: eventTypes$3,
      extractEvents: function(
        topLevelType,
        targetInst,
        nativeEvent,
        nativeEventTarget
      ) {
        var doc =
            nativeEventTarget.window === nativeEventTarget
              ? nativeEventTarget.document
              : 9 === nativeEventTarget.nodeType
                ? nativeEventTarget
                : nativeEventTarget.ownerDocument,
          JSCompiler_temp;
        if (!(JSCompiler_temp = !doc)) {
          a: {
            doc = getListeningForDocument(doc);
            JSCompiler_temp = registrationNameDependencies.onSelect;
            for (var i = 0; i < JSCompiler_temp.length; i++) {
              var dependency = JSCompiler_temp[i];
              if (!doc.hasOwnProperty(dependency) || !doc[dependency]) {
                doc = !1;
                break a;
              }
            }
            doc = !0;
          }
          JSCompiler_temp = !doc;
        }
        if (JSCompiler_temp) return null;
        doc = targetInst ? getNodeFromInstance$1(targetInst) : window;
        switch (topLevelType) {
          case "focus":
            if (isTextInputElement(doc) || "true" === doc.contentEditable)
              (activeElement$1 = doc),
                (activeElementInst$1 = targetInst),
                (lastSelection = null);
            break;
          case "blur":
            lastSelection = activeElementInst$1 = activeElement$1 = null;
            break;
          case "mousedown":
            mouseDown = !0;
            break;
          case "contextmenu":
          case "mouseup":
            return (
              (mouseDown = !1),
              constructSelectEvent(nativeEvent, nativeEventTarget)
            );
          case "selectionchange":
            if (skipSelectionChangeEvent) break;
          case "keydown":
          case "keyup":
            return constructSelectEvent(nativeEvent, nativeEventTarget);
        }
        return null;
      }
    };
  injection.injectEventPluginOrder(
    "ResponderEventPlugin SimpleEventPlugin TapEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(
      " "
    )
  );
  (function(Injected) {
    getFiberCurrentPropsFromNode = Injected.getFiberCurrentPropsFromNode;
    getInstanceFromNode = Injected.getInstanceFromNode;
    getNodeFromInstance = Injected.getNodeFromInstance;
  })(ReactDOMComponentTree);
  injection.injectEventPluginsByName({
    SimpleEventPlugin: SimpleEventPlugin,
    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
    ChangeEventPlugin: ChangeEventPlugin,
    SelectEventPlugin: SelectEventPlugin,
    BeforeInputEventPlugin: BeforeInputEventPlugin
  });
  var localDate = Date,
    localSetTimeout = "function" === typeof setTimeout ? setTimeout : void 0,
    localClearTimeout =
      "function" === typeof clearTimeout ? clearTimeout : void 0,
    localRequestAnimationFrame =
      "function" === typeof requestAnimationFrame
        ? requestAnimationFrame
        : void 0,
    localCancelAnimationFrame =
      "function" === typeof cancelAnimationFrame
        ? cancelAnimationFrame
        : void 0,
    now$1 = void 0;
  if (
    "object" === typeof performance &&
    "function" === typeof performance.now
  ) {
    var Performance = performance;
    now$1 = function() {
      return Performance.now();
    };
  } else
    now$1 = function() {
      return localDate.now();
    };
  var scheduleWork = void 0,
    cancelScheduledWork = void 0;
  if (canUseDOM) {
    var headOfPendingCallbacksLinkedList = null,
      tailOfPendingCallbacksLinkedList = null,
      nextSoonestTimeoutTime = -1,
      isIdleScheduled = !1,
      isAnimationFrameScheduled = !1,
      rafID = void 0,
      timeoutID = void 0,
      scheduleAnimationFrameWithFallbackSupport = function(callback) {
        rafID = localRequestAnimationFrame(function(timestamp) {
          localClearTimeout(timeoutID);
          callback(timestamp);
        });
        timeoutID = localSetTimeout(function() {
          localCancelAnimationFrame(rafID);
          callback(now$1());
        }, 100);
      },
      frameDeadline = 0,
      previousFrameTime = 33,
      activeFrameTime = 33,
      frameDeadlineObject = {
        didTimeout: !1,
        timeRemaining: function() {
          var remaining = frameDeadline - now$1();
          return 0 < remaining ? remaining : 0;
        }
      },
      callUnsafely = function(callbackConfig, arg) {
        var callback = callbackConfig.scheduledCallback,
          finishedCalling = !1;
        try {
          callback(arg), (finishedCalling = !0);
        } finally {
          cancelScheduledWork(callbackConfig),
            finishedCalling ||
              ((isIdleScheduled = !0), window.postMessage(messageKey, "*"));
        }
      },
      messageKey =
        "__reactIdleCallback$" +
        Math.random()
          .toString(36)
          .slice(2);
    window.addEventListener(
      "message",
      function(event) {
        if (
          event.source === window &&
          event.data === messageKey &&
          ((isIdleScheduled = !1), null !== headOfPendingCallbacksLinkedList)
        ) {
          if (null !== headOfPendingCallbacksLinkedList) {
            var currentTime = now$1();
            if (
              !(
                -1 === nextSoonestTimeoutTime ||
                nextSoonestTimeoutTime > currentTime
              )
            ) {
              event = -1;
              for (
                var timedOutCallbacks = [],
                  currentCallbackConfig = headOfPendingCallbacksLinkedList;
                null !== currentCallbackConfig;

              ) {
                var _timeoutTime = currentCallbackConfig.timeoutTime;
                -1 !== _timeoutTime && _timeoutTime <= currentTime
                  ? timedOutCallbacks.push(currentCallbackConfig)
                  : -1 !== _timeoutTime &&
                    (-1 === event || _timeoutTime < event) &&
                    (event = _timeoutTime);
                currentCallbackConfig = currentCallbackConfig.next;
              }
              if (0 < timedOutCallbacks.length)
                for (
                  frameDeadlineObject.didTimeout = !0,
                    currentTime = 0,
                    currentCallbackConfig = timedOutCallbacks.length;
                  currentTime < currentCallbackConfig;
                  currentTime++
                )
                  callUnsafely(
                    timedOutCallbacks[currentTime],
                    frameDeadlineObject
                  );
              nextSoonestTimeoutTime = event;
            }
          }
          for (
            event = now$1();
            0 < frameDeadline - event &&
            null !== headOfPendingCallbacksLinkedList;

          )
            (event = headOfPendingCallbacksLinkedList),
              (frameDeadlineObject.didTimeout = !1),
              callUnsafely(event, frameDeadlineObject),
              (event = now$1());
          null === headOfPendingCallbacksLinkedList ||
            isAnimationFrameScheduled ||
            ((isAnimationFrameScheduled = !0),
            scheduleAnimationFrameWithFallbackSupport(animationTick));
        }
      },
      !1
    );
    var animationTick = function(rafTime) {
      isAnimationFrameScheduled = !1;
      var nextFrameTime = rafTime - frameDeadline + activeFrameTime;
      nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime
        ? (8 > nextFrameTime && (nextFrameTime = 8),
          (activeFrameTime =
            nextFrameTime < previousFrameTime
              ? previousFrameTime
              : nextFrameTime))
        : (previousFrameTime = nextFrameTime);
      frameDeadline = rafTime + activeFrameTime;
      isIdleScheduled ||
        ((isIdleScheduled = !0), window.postMessage(messageKey, "*"));
    };
    scheduleWork = function(callback, options) {
      var timeoutTime = -1;
      null != options &&
        "number" === typeof options.timeout &&
        (timeoutTime = now$1() + options.timeout);
      if (
        -1 === nextSoonestTimeoutTime ||
        (-1 !== timeoutTime && timeoutTime < nextSoonestTimeoutTime)
      )
        nextSoonestTimeoutTime = timeoutTime;
      callback = {
        scheduledCallback: callback,
        timeoutTime: timeoutTime,
        prev: null,
        next: null
      };
      null === headOfPendingCallbacksLinkedList
        ? (headOfPendingCallbacksLinkedList = callback)
        : ((options = callback.prev = tailOfPendingCallbacksLinkedList),
          null !== options && (options.next = callback));
      tailOfPendingCallbacksLinkedList = callback;
      isAnimationFrameScheduled ||
        ((isAnimationFrameScheduled = !0),
        scheduleAnimationFrameWithFallbackSupport(animationTick));
      return callback;
    };
    cancelScheduledWork = function(callbackConfig) {
      if (
        null !== callbackConfig.prev ||
        headOfPendingCallbacksLinkedList === callbackConfig
      ) {
        var next = callbackConfig.next,
          prev = callbackConfig.prev;
        callbackConfig.next = null;
        callbackConfig.prev = null;
        null !== next
          ? null !== prev
            ? ((prev.next = next), (next.prev = prev))
            : ((next.prev = null), (headOfPendingCallbacksLinkedList = next))
          : null !== prev
            ? ((prev.next = null), (tailOfPendingCallbacksLinkedList = prev))
            : (tailOfPendingCallbacksLinkedList = headOfPendingCallbacksLinkedList = null);
      }
    };
  } else {
    var timeoutIds = new Map();
    scheduleWork = function(callback, options) {
      options = {
        scheduledCallback: callback,
        timeoutTime: 0,
        next: null,
        prev: null
      };
      var timeoutId = localSetTimeout(function() {
        callback({
          timeRemaining: function() {
            return Infinity;
          },
          didTimeout: !1
        });
      });
      timeoutIds.set(callback, timeoutId);
      return options;
    };
    cancelScheduledWork = function(callbackId) {
      var timeoutId = timeoutIds.get(callbackId.scheduledCallback);
      timeoutIds.delete(callbackId);
      localClearTimeout(timeoutId);
    };
  }
  var reusableSVGContainer = void 0,
    setInnerHTML = (function(func) {
      return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction
        ? function(arg0, arg1, arg2, arg3) {
            MSApp.execUnsafeLocalFunction(function() {
              return func(arg0, arg1, arg2, arg3);
            });
          }
        : func;
    })(function(node, html) {
      if (
        "http://www.w3.org/2000/svg" !== node.namespaceURI ||
        "innerHTML" in node
      )
        node.innerHTML = html;
      else {
        reusableSVGContainer =
          reusableSVGContainer || document.createElement("div");
        reusableSVGContainer.innerHTML = "<svg>" + html + "</svg>";
        for (html = reusableSVGContainer.firstChild; node.firstChild; )
          node.removeChild(node.firstChild);
        for (; html.firstChild; ) node.appendChild(html.firstChild);
      }
    }),
    setTextContent = function(node, text) {
      if (text) {
        var firstChild = node.firstChild;
        if (
          firstChild &&
          firstChild === node.lastChild &&
          3 === firstChild.nodeType
        ) {
          firstChild.nodeValue = text;
          return;
        }
      }
      node.textContent = text;
    },
    isUnitlessNumber = {
      animationIterationCount: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    },
    prefixes = ["Webkit", "ms", "Moz", "O"];
  Object.keys(isUnitlessNumber).forEach(function(prop) {
    prefixes.forEach(function(prefix) {
      prefix = prefix + prop.charAt(0).toUpperCase() + prop.substring(1);
      isUnitlessNumber[prefix] = isUnitlessNumber[prop];
    });
  });
  var voidElementTags = _assign(
      { menuitem: !0 },
      {
        area: !0,
        base: !0,
        br: !0,
        col: !0,
        embed: !0,
        hr: !0,
        img: !0,
        input: !0,
        keygen: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0
      }
    ),
    ReactDOMFiberComponent = {
      createElement: createElement$1,
      createTextNode: createTextNode$1,
      setInitialProperties: setInitialProperties$1,
      diffProperties: diffProperties$1,
      updateProperties: updateProperties$1,
      diffHydratedProperties: diffHydratedProperties$1,
      diffHydratedText: diffHydratedText$1,
      warnForUnmatchedText: function(textNode, text) {},
      warnForDeletedHydratableElement: function(parentNode, child) {},
      warnForDeletedHydratableText: function(parentNode, child) {},
      warnForInsertedHydratedElement: function(parentNode, tag, props) {},
      warnForInsertedHydratedText: function(parentNode, text) {},
      restoreControlledState: function(domElement, tag, props) {
        switch (tag) {
          case "input":
            updateWrapper(domElement, props);
            tag = props.name;
            if ("radio" === props.type && null != tag) {
              for (props = domElement; props.parentNode; )
                props = props.parentNode;
              props = props.querySelectorAll(
                "input[name=" + JSON.stringify("" + tag) + '][type="radio"]'
              );
              for (tag = 0; tag < props.length; tag++) {
                var otherNode = props[tag];
                if (
                  otherNode !== domElement &&
                  otherNode.form === domElement.form
                ) {
                  var otherProps = getFiberCurrentPropsFromNode$1(otherNode);
                  otherProps ? void 0 : reactProdInvariant("90");
                  updateValueIfChanged(otherNode);
                  updateWrapper(otherNode, otherProps);
                }
              }
            }
            break;
          case "textarea":
            updateWrapper$1(domElement, props);
            break;
          case "select":
            (tag = props.value),
              null != tag &&
                updateOptions(domElement, !!props.multiple, tag, !1);
        }
      }
    },
    createElement = createElement$1,
    createTextNode = createTextNode$1,
    setInitialProperties = setInitialProperties$1,
    diffProperties = diffProperties$1,
    updateProperties = updateProperties$1,
    diffHydratedProperties = diffHydratedProperties$1,
    diffHydratedText = diffHydratedText$1,
    precacheFiberNode$1 = precacheFiberNode,
    updateFiberProps$1 = updateFiberProps,
    eventsEnabled = null,
    selectionInformation = null,
    now = now$1,
    scheduleDeferredCallback = scheduleWork,
    cancelDeferredCallback = cancelScheduledWork;
  new Set();
  var valueStack = [],
    index = -1,
    emptyContextObject = {},
    contextStackCursor = { current: emptyContextObject },
    didPerformWorkStackCursor = { current: !1 },
    previousContext = emptyContextObject,
    onCommitFiberRoot = null,
    onCommitFiberUnmount = null,
    hasForceUpdate = !1,
    valueCursor = { current: null },
    changedBitsCursor = { current: 0 },
    currentlyRenderingFiber = null,
    lastContextDependency = null,
    lastContext = null,
    NO_CONTEXT = {},
    contextStackCursor$1 = { current: NO_CONTEXT },
    contextFiberStackCursor = { current: NO_CONTEXT },
    rootInstanceStackCursor = { current: NO_CONTEXT },
    emptyRefsObject = new React.Component().refs,
    classComponentUpdater = {
      isMounted: function(component) {
        return (component = component._reactInternalFiber)
          ? 2 === isFiberMountedImpl(component)
          : !1;
      },
      enqueueSetState: function(inst, payload, callback) {
        inst = inst._reactInternalFiber;
        var currentTime = requestCurrentTime();
        currentTime = computeExpirationForFiber(currentTime, inst);
        var update = createUpdate(currentTime);
        update.payload = payload;
        void 0 !== callback &&
          null !== callback &&
          (update.callback = callback);
        enqueueUpdate(inst, update);
        scheduleWork$1(inst, currentTime);
      },
      enqueueReplaceState: function(inst, payload, callback) {
        inst = inst._reactInternalFiber;
        var currentTime = requestCurrentTime();
        currentTime = computeExpirationForFiber(currentTime, inst);
        var update = createUpdate(currentTime);
        update.tag = 1;
        update.payload = payload;
        void 0 !== callback &&
          null !== callback &&
          (update.callback = callback);
        enqueueUpdate(inst, update);
        scheduleWork$1(inst, currentTime);
      },
      enqueueForceUpdate: function(inst, callback) {
        inst = inst._reactInternalFiber;
        var currentTime = requestCurrentTime();
        currentTime = computeExpirationForFiber(currentTime, inst);
        var update = createUpdate(currentTime);
        update.tag = 2;
        void 0 !== callback &&
          null !== callback &&
          (update.callback = callback);
        enqueueUpdate(inst, update);
        scheduleWork$1(inst, currentTime);
      }
    },
    isArray$1 = Array.isArray,
    reconcileChildFibers = ChildReconciler(!0),
    mountChildFibers = ChildReconciler(!1),
    hydrationParentFiber = null,
    nextHydratableInstance = null,
    isHydrating = !1,
    ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner,
    updateHostContainer = void 0,
    updateHostComponent$1 = void 0,
    updateHostText$1 = void 0;
  updateHostContainer = function(workInProgress) {};
  updateHostComponent$1 = function(
    current,
    workInProgress,
    updatePayload,
    type,
    oldProps,
    newProps,
    rootContainerInstance,
    currentHostContext
  ) {
    (workInProgress.updateQueue = updatePayload) && markUpdate(workInProgress);
  };
  updateHostText$1 = function(current, workInProgress, oldText, newText) {
    oldText !== newText && markUpdate(workInProgress);
  };
  var Dispatcher = { readContext: readContext },
    ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,
    lastUniqueAsyncExpiration = 0,
    expirationContext = 0,
    isWorking = !1,
    nextUnitOfWork = null,
    nextRoot = null,
    nextRenderExpirationTime = 0,
    nextRenderDidError = !1,
    nextEffect = null,
    isCommitting$1 = !1,
    legacyErrorBoundariesThatAlreadyFailed = null,
    firstScheduledRoot = null,
    lastScheduledRoot = null,
    callbackExpirationTime = 0,
    callbackID = void 0,
    isRendering = !1,
    nextFlushedRoot = null,
    nextFlushedExpirationTime = 0,
    lowestPendingInteractiveExpirationTime = 0,
    deadlineDidExpire = !1,
    hasUnhandledError = !1,
    unhandledError = null,
    deadline = null,
    isBatchingUpdates = !1,
    isUnbatchingUpdates = !1,
    isBatchingInteractiveUpdates = !1,
    completedBatches = null,
    originalStartTimeMs = now(),
    currentRendererTime = ((originalStartTimeMs / 10) | 0) + 2,
    currentSchedulerTime = currentRendererTime,
    NESTED_UPDATE_LIMIT = 50,
    nestedUpdateCount = 0,
    lastCommittedRootDuringThisBatch = null,
    timeHeuristicForUnitOfWork = 1,
    DOMRenderer = {
      updateContainerAtExpirationTime: updateContainerAtExpirationTime,
      createContainer: function(containerInfo, isAsync, hydrate) {
        return createFiberRoot(containerInfo, isAsync, hydrate);
      },
      updateContainer: updateContainer,
      flushRoot: flushRoot,
      requestWork: requestWork,
      computeUniqueAsyncExpiration: computeUniqueAsyncExpiration,
      batchedUpdates: batchedUpdates$1,
      unbatchedUpdates: unbatchedUpdates,
      deferredUpdates: deferredUpdates,
      syncUpdates: syncUpdates,
      interactiveUpdates: interactiveUpdates$1,
      flushInteractiveUpdates: function() {
        isRendering ||
          0 === lowestPendingInteractiveExpirationTime ||
          (performWork(lowestPendingInteractiveExpirationTime, null),
          (lowestPendingInteractiveExpirationTime = 0));
      },
      flushControlled: flushControlled,
      flushSync: flushSync,
      getPublicRootInstance: getPublicRootInstance,
      findHostInstance: findHostInstance,
      findHostInstanceWithNoPortals: function(fiber) {
        fiber = findCurrentHostFiberWithNoPortals(fiber);
        return null === fiber ? null : fiber.stateNode;
      },
      injectIntoDevTools: injectIntoDevTools
    };
  injection$2.injectFiberControlledHostComponent(ReactDOMFiberComponent);
  ReactBatch.prototype.render = function(children) {
    this._defer ? void 0 : reactProdInvariant("250");
    this._hasChildren = !0;
    this._children = children;
    var internalRoot = this._root._internalRoot,
      expirationTime = this._expirationTime,
      work = new ReactWork();
    updateContainerAtExpirationTime(
      children,
      internalRoot,
      null,
      expirationTime,
      work._onCommit
    );
    return work;
  };
  ReactBatch.prototype.then = function(onComplete) {
    if (this._didComplete) onComplete();
    else {
      var callbacks = this._callbacks;
      null === callbacks && (callbacks = this._callbacks = []);
      callbacks.push(onComplete);
    }
  };
  ReactBatch.prototype.commit = function() {
    var internalRoot = this._root._internalRoot,
      firstBatch = internalRoot.firstBatch;
    this._defer && null !== firstBatch ? void 0 : reactProdInvariant("251");
    if (this._hasChildren) {
      var expirationTime = this._expirationTime;
      if (firstBatch !== this) {
        this._hasChildren &&
          ((expirationTime = this._expirationTime = firstBatch._expirationTime),
          this.render(this._children));
        for (var previous = null, batch = firstBatch; batch !== this; )
          (previous = batch), (batch = batch._next);
        null === previous ? reactProdInvariant("251") : void 0;
        previous._next = batch._next;
        this._next = firstBatch;
        internalRoot.firstBatch = this;
      }
      this._defer = !1;
      flushRoot(internalRoot, expirationTime);
      firstBatch = this._next;
      this._next = null;
      firstBatch = internalRoot.firstBatch = firstBatch;
      null !== firstBatch &&
        firstBatch._hasChildren &&
        firstBatch.render(firstBatch._children);
    } else (this._next = null), (this._defer = !1);
  };
  ReactBatch.prototype._onComplete = function() {
    if (!this._didComplete) {
      this._didComplete = !0;
      var callbacks = this._callbacks;
      if (null !== callbacks)
        for (var i = 0; i < callbacks.length; i++) (0, callbacks[i])();
    }
  };
  ReactWork.prototype.then = function(onCommit) {
    if (this._didCommit) onCommit();
    else {
      var callbacks = this._callbacks;
      null === callbacks && (callbacks = this._callbacks = []);
      callbacks.push(onCommit);
    }
  };
  ReactWork.prototype._onCommit = function() {
    if (!this._didCommit) {
      this._didCommit = !0;
      var callbacks = this._callbacks;
      if (null !== callbacks)
        for (var i = 0; i < callbacks.length; i++) {
          var _callback2 = callbacks[i];
          "function" !== typeof _callback2
            ? reactProdInvariant("191", _callback2)
            : void 0;
          _callback2();
        }
    }
  };
  ReactRoot.prototype.render = function(children, callback) {
    var root = this._internalRoot,
      work = new ReactWork();
    callback = void 0 === callback ? null : callback;
    null !== callback && work.then(callback);
    updateContainer(children, root, null, work._onCommit);
    return work;
  };
  ReactRoot.prototype.unmount = function(callback) {
    var root = this._internalRoot,
      work = new ReactWork();
    callback = void 0 === callback ? null : callback;
    null !== callback && work.then(callback);
    updateContainer(null, root, null, work._onCommit);
    return work;
  };
  ReactRoot.prototype.legacy_renderSubtreeIntoContainer = function(
    parentComponent,
    children,
    callback
  ) {
    var root = this._internalRoot,
      work = new ReactWork();
    callback = void 0 === callback ? null : callback;
    null !== callback && work.then(callback);
    updateContainer(children, root, parentComponent, work._onCommit);
    return work;
  };
  ReactRoot.prototype.createBatch = function() {
    var batch = new ReactBatch(this),
      expirationTime = batch._expirationTime,
      internalRoot = this._internalRoot,
      firstBatch = internalRoot.firstBatch;
    if (null === firstBatch)
      (internalRoot.firstBatch = batch), (batch._next = null);
    else {
      for (
        internalRoot = null;
        null !== firstBatch && firstBatch._expirationTime <= expirationTime;

      )
        (internalRoot = firstBatch), (firstBatch = firstBatch._next);
      batch._next = firstBatch;
      null !== internalRoot && (internalRoot._next = batch);
    }
    return batch;
  };
  (function(renderer) {
    _batchedUpdates = renderer.batchedUpdates;
    _interactiveUpdates = renderer.interactiveUpdates;
    _flushInteractiveUpdates = renderer.flushInteractiveUpdates;
  })(DOMRenderer);
  var ReactDOM = {
    createPortal: createPortal,
    findDOMNode: function(componentOrElement) {
      return null == componentOrElement
        ? null
        : 1 === componentOrElement.nodeType
          ? componentOrElement
          : findHostInstance(componentOrElement);
    },
    hydrate: function(element, container, callback) {
      return legacyRenderSubtreeIntoContainer(
        null,
        element,
        container,
        !0,
        callback
      );
    },
    render: function(element, container, callback) {
      return legacyRenderSubtreeIntoContainer(
        null,
        element,
        container,
        !1,
        callback
      );
    },
    unstable_renderSubtreeIntoContainer: function(
      parentComponent,
      element,
      containerNode,
      callback
    ) {
      null == parentComponent || void 0 === parentComponent._reactInternalFiber
        ? reactProdInvariant("38")
        : void 0;
      return legacyRenderSubtreeIntoContainer(
        parentComponent,
        element,
        containerNode,
        !1,
        callback
      );
    },
    unmountComponentAtNode: function(container) {
      isValidContainer(container) ? void 0 : reactProdInvariant("40");
      return container._reactRootContainer
        ? (unbatchedUpdates(function() {
            legacyRenderSubtreeIntoContainer(
              null,
              null,
              container,
              !1,
              function() {
                container._reactRootContainer = null;
              }
            );
          }),
          !0)
        : !1;
    },
    unstable_createPortal: function() {
      return createPortal.apply(void 0, arguments);
    },
    unstable_batchedUpdates: batchedUpdates$1,
    unstable_deferredUpdates: deferredUpdates,
    unstable_interactiveUpdates: interactiveUpdates$1,
    flushSync: flushSync,
    unstable_flushControlled: flushControlled,
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
      EventPluginHub: EventPluginHub,
      EventPluginRegistry: EventPluginRegistry,
      EventPropagators: EventPropagators,
      ReactControlledComponent: ReactControlledComponent,
      ReactDOMComponentTree: ReactDOMComponentTree,
      ReactDOMEventListener: ReactDOMEventListener
    },
    unstable_createRoot: function(container, options) {
      return new ReactRoot(
        container,
        !0,
        null != options && !0 === options.hydrate
      );
    }
  };
  injectIntoDevTools({
    findFiberByHostInstance: getClosestInstanceFromNode,
    bundleType: 0,
    version: "16.4.1",
    rendererPackageName: "react-dom"
  });
  var ReactDOM$2 = { default: ReactDOM },
    ReactDOM$3 = (ReactDOM$2 && ReactDOM) || ReactDOM$2;
  return ReactDOM$3.default ? ReactDOM$3.default : ReactDOM$3;
});
